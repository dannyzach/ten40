This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-20T22:35:30.865Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
components/
  common/
    DialogWrapper.tsx
    ErrorMessage.tsx
    index.ts
    LoadingSpinner.tsx
  Documents/
    Tables/
      BaseDocumentTable.tsx
      DonationDocumentTable.tsx
      ExpenseDocumentTable.tsx
      Form1099DocumentTable.tsx
      index.ts
      W2DocumentTable.tsx
    DocumentFilters.tsx
    DocumentsFilters.tsx
    DocumentsTable.tsx
    DocumentsTabs.tsx
    DocumentsView.tsx
    DocumentUploadArea.tsx
    DocumentUploadFab.tsx
    EditableCell.tsx
    ExpenseFilters.tsx
  GlobalHeader/
    GlobalHeader.tsx
  Layout/
    Layout.tsx
  LeftNav/
    LeftNav.tsx
  ErrorBoundary.tsx
  ImageViewer.tsx
  JsonViewer.tsx
  ProtectedRoute.tsx
  ReceiptDetail.tsx
  ReceiptList.tsx
  ReceiptTable.tsx
  ReceiptUploader.tsx
  RouteGuard.tsx
  UploadArea.tsx
config/
  index.ts
contexts/
  AppContext.tsx
  AuthContext.tsx
  index.ts
  SearchContext.tsx
hooks/
  useClickAway.ts
  useDocumentManagement.ts
  useSearch.ts
lib/
  api/
    auth.ts
    client.ts
    documents.ts
  createEmotionCache.ts
pages/
  documents/
    index.tsx
  receipt/
    [id].tsx
  _app.tsx
  1040.tsx
  dashboard.tsx
  documents-temp.tsx
  index.tsx
  login.tsx
  profile.tsx
  signup.tsx
  test-auth.tsx
services/
  apiClient.ts
styles/
  globals.css
  theme.ts
types/
  documents.ts
  filters.ts
  index.ts
.env.development
.eslintrc.js
.gitignore
config.ts
next.config.js
package.json
railway.toml
tsconfig.json

================================================================
Files
================================================================

================
File: components/common/DialogWrapper.tsx
================
import { Dialog, DialogTitle, DialogContent, IconButton } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';

interface DialogWrapperProps {
    title: string;
    open: boolean;
    onClose: () => void;
    children: React.ReactNode;
}

export const DialogWrapper = ({ title, open, onClose, children }: DialogWrapperProps) => (
    <Dialog open={open} onClose={onClose} maxWidth="lg" fullWidth>
        <DialogTitle sx={{ m: 0, p: 2, display: 'flex', justifyContent: 'space-between' }}>
            {title}
            <IconButton onClick={onClose}><CloseIcon /></IconButton>
        </DialogTitle>
        <DialogContent>
            {children}
        </DialogContent>
    </Dialog>
);

================
File: components/common/ErrorMessage.tsx
================
import { Alert, Box } from '@mui/material';

interface ErrorMessageProps {
  message: string;
}

export default function ErrorMessage({ message }: ErrorMessageProps) {
  return (
    <Box sx={{ my: 2 }}>
      <Alert severity="error">{message}</Alert>
    </Box>
  );
}

================
File: components/common/index.ts
================
export * from './ErrorMessage';
export * from './LoadingSpinner';
export * from './DialogWrapper';
export * from '../ReceiptTable';

================
File: components/common/LoadingSpinner.tsx
================
import { Box, CircularProgress, type SxProps } from '@mui/material';

interface LoadingSpinnerProps {
  minHeight?: string | number;
  sx?: SxProps;
}

export default function LoadingSpinner({ minHeight = '200px', sx }: LoadingSpinnerProps) {
  return (
    <Box
      display="flex"
      justifyContent="center"
      alignItems="center"
      minHeight={minHeight}
      sx={sx}
    >
      <CircularProgress />
    </Box>
  );
}

================
File: components/Documents/Tables/BaseDocumentTable.tsx
================
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Paper,
    Box,
    CircularProgress,
    Checkbox,
    IconButton,
    Tooltip,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    Button,
    Snackbar,
    Alert,
    TableSortLabel,
    Typography
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import VisibilityIcon from '@mui/icons-material/Visibility';
import { Document, DocumentType } from '@/types';
import { documentsApi } from '@/lib/api/documents';
import { EditableCell } from '../EditableCell';
import { ImageViewer } from '@/components/ImageViewer';
import { DocumentFilters } from '../DocumentFilters';

// Define allowed value types for document fields
type DocumentValue = string | number | null;

export interface Column<T> {
    id: keyof T | 'actions' | 'category';
    label: string;
    minWidth?: number;
    align?: 'left' | 'right' | 'center';
    format?: (value: any) => string;
    editable?: boolean;
    editType?: 'text' | 'date' | 'amount' | 'select';
    options?: string[];
}

interface BaseDocumentTableProps<T extends Document> {
    type: DocumentType;
    columns: Column<T>[];
    filters: any;
    onFilterChange: (filters: any) => void;
}

const TableToolbar = ({ 
    type,
    numSelected, 
    onSelectAll, 
    onDelete,
    filters,
    onFilterChange,
    availableOptions
}: { 
    type: DocumentType;
    numSelected: number;
    onSelectAll: (event: React.ChangeEvent<HTMLInputElement>) => void;
    onDelete: () => void;
    filters: any;
    onFilterChange: (filters: any) => void;
    availableOptions: Record<string, string[]>;
}) => (
    <Box sx={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        borderBottom: 1,
        borderColor: 'divider',
        bgcolor: numSelected > 0 ? 'action.selected' : 'background.paper',
        px: 2,
        py: 1,
    }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <Checkbox
                indeterminate={numSelected > 0}
                checked={numSelected > 0}
                onChange={onSelectAll}
            />
            {numSelected > 0 ? (
                <>
                    <Typography>
                        {numSelected} selected
                    </Typography>
                    <Tooltip title="Delete">
                        <IconButton onClick={onDelete} size="small">
                            <DeleteIcon />
                        </IconButton>
                    </Tooltip>
                </>
            ) : (
                <Typography variant="h6" component="div">
                    {type}
                </Typography>
            )}
        </Box>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
            <DocumentFilters
                type={type}
                filters={filters}
                onFilterChange={onFilterChange}
                availableOptions={availableOptions}
                variant="toolbar"
            />
        </Box>
    </Box>
);

export function BaseDocumentTable<T extends Document>({ 
    type,
    columns,
    filters,
    onFilterChange
}: BaseDocumentTableProps<T>) {
    const [documents, setDocuments] = useState<T[]>([]);
    const [loading, setLoading] = useState(true);
    const [orderBy, setOrderBy] = useState<string>('');
    const [order, setOrder] = useState<'asc' | 'desc'>('asc');
    const [selected, setSelected] = useState<number[]>([]);
    const [availableOptions, setAvailableOptions] = useState<Record<string, string[]>>({});
    const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
    const [selectedImage, setSelectedImage] = useState<string | null>(null);
    const [snackbar, setSnackbar] = useState({
        open: false,
        message: '',
        severity: 'success' as const
    });
    const [editingCell, setEditingCell] = useState<{
        id: number;
        field: keyof T;
    } | null>(null);

    // Fetch documents
    useEffect(() => {
        fetchDocuments();
    }, [type]);

    const fetchDocuments = async () => {
        try {
            setLoading(true);
            const response = await documentsApi.getDocuments();
            setDocuments(response.data.filter((doc: Document) => doc.type === type) as T[]);
        } catch (error) {
            showError('Failed to fetch documents');
        } finally {
            setLoading(false);
        }
    };

    // Selection handlers
    const handleSelectAll = (event: React.ChangeEvent<HTMLInputElement>) => {
        if (event.target.checked) {
            setSelected(documents.map(doc => doc.id));
        } else {
            setSelected([]);
        }
    };

    const handleSelectOne = (id: number) => {
        const selectedIndex = selected.indexOf(id);
        let newSelected: number[] = [];

        if (selectedIndex === -1) {
            newSelected = [...selected, id];
        } else {
            newSelected = selected.filter(item => item !== id);
        }

        setSelected(newSelected);
    };

    // Delete handlers
    const handleDelete = async (ids: number[]) => {
        try {
            await documentsApi.deleteDocuments(ids);
            await fetchDocuments();
            setSelected([]);
            showSuccess('Documents deleted successfully');
        } catch (error) {
            showError('Failed to delete documents');
        }
        setDeleteDialogOpen(false);
    };

    // Update handler
    const handleUpdateField = async (documentId: number, field: keyof T, value: string): Promise<void> => {
        try {
            await documentsApi.updateDocument(documentId, {
                [field]: value
            });
            showSuccess('Document updated successfully');
            await fetchDocuments();
        } catch (error) {
            showError('Failed to update document');
            throw error;
        }
    };

    // Notification handlers
    const showSuccess = (message: string) => {
        setSnackbar({ open: true, message, severity: 'success' });
    };

    const showError = (message: string) => {
        setSnackbar({ open: true, message, severity: 'error' });
    };

    const handleCellClick = (id: number, field: keyof T) => {
        const column = columns.find(col => col.id === field);
        if (column?.editable) {
            setEditingCell({ id, field });
        }
    };

    const handleCellBlur = () => {
        setEditingCell(null);
    };

    const formatCellValue = (value: DocumentValue, column: Column<T>) => {
        if (value == null) return '';
        
        return String(value);
    };

    // Sorting logic from DocumentsTable
    const sortedDocuments = useMemo(() => {
        if (!orderBy) return documents;

        return [...documents].sort((a, b) => {
            const aValue = a[orderBy as keyof T];
            const bValue = b[orderBy as keyof T];

            if (order === 'desc') {
                return bValue > aValue ? 1 : -1;
            }
            return aValue > bValue ? 1 : -1;
        });
    }, [documents, orderBy, order]);

    const handleSort = (columnId: string) => {
        const isAsc = orderBy === columnId && order === 'asc';
        setOrder(isAsc ? 'desc' : 'asc');
        setOrderBy(columnId);
    };

    // Render functions
    const renderActions = (document: T) => (
        <Box sx={{ display: 'flex', gap: 1 }}>
            {document.image_path && (
                <Tooltip title="View Image">
                    <IconButton
                        size="small"
                        onClick={() => setSelectedImage(document.image_path)}
                    >
                        <VisibilityIcon fontSize="small" />
                    </IconButton>
                </Tooltip>
            )}
            <Tooltip title="Edit">
                <IconButton size="small">
                    <EditIcon fontSize="small" />
                </IconButton>
            </Tooltip>
            <Tooltip title="Delete">
                <IconButton
                    size="small"
                    onClick={() => {
                        setSelected([document.id]);
                        setDeleteDialogOpen(true);
                    }}
                >
                    <DeleteIcon fontSize="small" />
                </IconButton>
            </Tooltip>
        </Box>
    );

    const renderCell = (document: T, column: Column<T>) => {
        const value = document[column.id];
        const isEditing = editingCell?.id === document.id && editingCell?.field === column.id;

        if (column.editable && isEditing) {
            return (
                <EditableCell
                    value={String(value ?? '')}
                    type={column.editType || 'text'}
                    options={column.options}
                    onSave={async (newValue) => {
                        await handleUpdateField(document.id, column.id, newValue);
                        setEditingCell(null);
                    }}
                    onBlur={handleCellBlur}
                    autoFocus
                />
            );
        }

        return (
            <Box
                onClick={() => handleCellClick(document.id, column.id)}
                sx={{ 
                    cursor: column.editable ? 'pointer' : 'default',
                    '&:hover': column.editable ? {
                        backgroundColor: 'action.hover',
                        borderRadius: 1
                    } : {}
                }}
            >
                {formatCellValue(value as DocumentValue, column)}
            </Box>
        );
    };

    if (loading) {
        return (
            <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
                <CircularProgress />
            </Box>
        );
    }

    return (
        <>
            <TableContainer component={Paper}>
                <TableToolbar
                    type={type}
                    numSelected={selected.length}
                    onSelectAll={handleSelectAll}
                    onDelete={() => handleDelete(selected)}
                    filters={filters}
                    onFilterChange={onFilterChange}
                    availableOptions={availableOptions}
                />
                <Table stickyHeader>
                    <TableHead>
                        <TableRow>
                            {columns.map((column) => (
                                <TableCell
                                    key={String(column.id)}
                                    align={column.align}
                                    style={{ minWidth: column.minWidth }}
                                >
                                    {column.label}
                                </TableCell>
                            ))}
                            <TableCell align="right">Actions</TableCell>
                        </TableRow>
                    </TableHead>
                    <TableBody>
                        {sortedDocuments.map((document) => (
                            <TableRow 
                                hover 
                                key={document.id}
                                selected={selected.includes(document.id)}
                            >
                                <TableCell padding="checkbox">
                                    <Checkbox
                                        checked={selected.includes(document.id)}
                                        onChange={() => handleSelectOne(document.id)}
                                    />
                                </TableCell>
                                {columns.map((column) => (
                                    <TableCell 
                                        key={String(column.id)} 
                                        align={column.align}
                                        sx={{ 
                                            p: 1,
                                            minWidth: column.minWidth 
                                        }}
                                    >
                                        {renderCell(document, column)}
                                    </TableCell>
                                ))}
                                <TableCell align="right">
                                    {renderActions(document)}
                                </TableCell>
                            </TableRow>
                        ))}
                    </TableBody>
                </Table>
            </TableContainer>

            <ImageViewer
                open={!!selectedImage}
                imageUrl={selectedImage || ''}
                onClose={() => setSelectedImage(null)}
            />

            <Dialog open={deleteDialogOpen} onClose={() => setDeleteDialogOpen(false)}>
                <DialogTitle>Confirm Delete</DialogTitle>
                <DialogContent>
                    Are you sure you want to delete {selected.length} selected document(s)?
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setDeleteDialogOpen(false)}>Cancel</Button>
                    <Button 
                        onClick={() => handleDelete(selected)}
                        color="error"
                    >
                        Delete
                    </Button>
                </DialogActions>
            </Dialog>

            <Snackbar
                open={snackbar.open}
                autoHideDuration={6000}
                onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}
            >
                <Alert severity={snackbar.severity}>
                    {snackbar.message}
                </Alert>
            </Snackbar>
        </>
    );
}

================
File: components/Documents/Tables/DonationDocumentTable.tsx
================
import React from 'react';
import { DonationDocument, DocumentType } from '@/types';
import { BaseDocumentTable, Column } from './BaseDocumentTable';

const COLUMNS: Column<DonationDocument>[] = [
    { id: 'charityName', label: 'Charity', minWidth: 170 },
    { 
        id: 'amount',
        label: 'Amount',
        minWidth: 100,
        align: 'right',
        format: (value: string | number | null) => {
            if (value == null) return '';
            const numValue = typeof value === 'string' ? parseFloat(value) : value;
            return numValue.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
        }
    },
    { id: 'donationType', label: 'Type', minWidth: 100 },
    { id: 'date', label: 'Date', minWidth: 100 },
    { 
        id: 'status', 
        label: 'Status', 
        minWidth: 100, 
        align: 'center'
    }
];

export const DonationDocumentTable: React.FC<{ filters: any; onFilterChange: (f: any) => void }> = ({ 
    filters, 
    onFilterChange 
}) => (
    <BaseDocumentTable<DonationDocument>
        type={DocumentType.DONATION}
        columns={COLUMNS}
        filters={filters}
        onFilterChange={onFilterChange}
    />
);

================
File: components/Documents/Tables/ExpenseDocumentTable.tsx
================
import React from 'react';
import { ExpenseDocument, DocumentType } from '@/types';
import { BaseDocumentTable, Column } from './BaseDocumentTable';

const COLUMNS: Column<ExpenseDocument>[] = [
    { 
        id: 'vendor',
        label: 'Vendor',
        minWidth: 170,
        editable: true,
        editType: 'text'
    },
    { 
        id: 'amount',
        label: 'Amount',
        minWidth: 100,
        align: 'right',
        editable: true,
        editType: 'amount',
        format: (value: string | number | null) => {
            if (value == null) return '';
            const numValue = typeof value === 'string' ? parseFloat(value) : value;
            return numValue.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
        }
    },
    { 
        id: 'date',
        label: 'Date',
        minWidth: 100,
        editable: true,
        editType: 'date',
        format: (value: string | number | null) => {
            if (value == null) return '';
            return new Date(String(value)).toLocaleDateString();
        }
    },
    { 
        id: 'payment_method' as keyof ExpenseDocument,
        label: 'Payment Method',
        minWidth: 130,
        editable: true,
        editType: 'select',
        options: ['Credit Card', 'Debit Card', 'Cash', 'Check', 'Wire Transfer', 'Other']
    },
    { 
        id: 'category' as keyof ExpenseDocument,
        label: 'Category',
        minWidth: 150,
        editable: true,
        editType: 'select',
        options: [] // Will be populated from backend
    },
    { 
        id: 'status', 
        label: 'Status', 
        minWidth: 100, 
        align: 'center'
    }
];

export const ExpenseDocumentTable: React.FC<{ filters: any; onFilterChange: (f: any) => void }> = ({ 
    filters, 
    onFilterChange 
}) => (
    <BaseDocumentTable<ExpenseDocument>
        type={DocumentType.EXPENSE}
        columns={COLUMNS}
        filters={filters}
        onFilterChange={onFilterChange}
    />
);

================
File: components/Documents/Tables/Form1099DocumentTable.tsx
================
import React from 'react';
import { Form1099Document, DocumentType } from '@/types';
import { BaseDocumentTable, Column } from './BaseDocumentTable';

const COLUMNS: Column<Form1099Document>[] = [
    { id: 'employer', label: 'Payer', minWidth: 170 },
    { 
        id: 'nonEmpCompensation',
        label: 'Amount',
        minWidth: 100,
        align: 'right',
        format: (value: string | number | null) => {
            if (value == null) return '';
            const numValue = typeof value === 'string' ? parseFloat(value) : value;
            return numValue.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
        }
    },
    { 
        id: 'status', 
        label: 'Status', 
        minWidth: 100, 
        align: 'center'
    }
];

export const Form1099DocumentTable: React.FC<{ filters: any; onFilterChange: (f: any) => void }> = ({ 
    filters, 
    onFilterChange 
}) => (
    <BaseDocumentTable<Form1099Document>
        type={DocumentType.FORM_1099}
        columns={COLUMNS}
        filters={filters}
        onFilterChange={onFilterChange}
    />
);

================
File: components/Documents/Tables/index.ts
================
export * from './ExpenseDocumentTable';
export * from './W2DocumentTable';
export * from './Form1099DocumentTable';
export * from './DonationDocumentTable';

================
File: components/Documents/Tables/W2DocumentTable.tsx
================
import React from 'react';
import { W2Document, DocumentType } from '@/types';
import { BaseDocumentTable, Column } from './BaseDocumentTable';

const COLUMNS: Column<W2Document>[] = [
    { id: 'employer', label: 'Employer', minWidth: 170 },
    { 
        id: 'wages',
        label: 'Wages',
        minWidth: 100,
        align: 'right',
        format: (value: string | number | null) => {
            if (value == null) return '';
            const numValue = typeof value === 'string' ? parseFloat(value) : value;
            return numValue.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
        }
    },
    { 
        id: 'fedWithholding',
        label: 'Fed Withholding',
        minWidth: 130,
        align: 'right',
        format: (value: string | number | null) => {
            if (value == null) return '';
            const numValue = typeof value === 'string' ? parseFloat(value) : value;
            return numValue.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
        }
    },
    { 
        id: 'status', 
        label: 'Status', 
        minWidth: 100, 
        align: 'center'
    }
];

export const W2DocumentTable: React.FC<{ filters: any; onFilterChange: (f: any) => void }> = ({ 
    filters, 
    onFilterChange 
}) => (
    <BaseDocumentTable<W2Document>
        type={DocumentType.W2}
        columns={COLUMNS}
        filters={filters}
        onFilterChange={onFilterChange}
    />
);

================
File: components/Documents/DocumentFilters.tsx
================
import React, { useState, useEffect } from 'react';
import {
    Box,
    Accordion,
    AccordionSummary,
    AccordionDetails,
    Typography,
    TextField,
    Select,
    MenuItem,
    FormControl,
    InputLabel,
    Chip,
    Button,
    Menu,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import TuneIcon from '@mui/icons-material/Tune';
import RestartAltIcon from '@mui/icons-material/RestartAlt';
import { DocumentType } from '@/types';
import { DocumentFilter } from '@/types/filters';
import apiClient from '@/services/apiClient';

interface FilterField {
    type: 'number-range' | 'date-range' | 'multi-select';
    label: string;
    field: string;
    options?: string[]; // For multi-select
}

interface FilterOptions {
    categories: string[];
    payment_methods: string[];
    statuses: string[];
    vendors: string[];
}

const FILTER_CONFIG: Record<DocumentType, FilterField[]> = {
    'W-2': [
        { type: 'multi-select', label: 'Employer', field: 'employer' },
        { type: 'number-range', label: 'Wages', field: 'wageRange' },
        { type: 'number-range', label: 'Withholding', field: 'withHoldingRange' },
        { type: 'date-range', label: 'Date', field: 'dateRange' },
        { type: 'multi-select', label: 'Status', field: 'status' }
    ],
    '1099': [
        { type: 'multi-select', label: 'Employer', field: 'employer' },
        { type: 'number-range', label: 'Amount', field: 'amountRange' },
        { type: 'date-range', label: 'Date', field: 'dateRange' },
        { type: 'multi-select', label: 'Status', field: 'status' }
    ],
    'Expenses': [
        { type: 'multi-select', label: 'Vendor', field: 'vendor' },
        { type: 'number-range', label: 'Amount', field: 'amountRange' },
        { type: 'date-range', label: 'Date', field: 'dateRange' },
        { type: 'multi-select', label: 'Payment Method', field: 'paymentMethod' },
        { type: 'multi-select', label: 'Expense Type', field: 'category' },
        { type: 'multi-select', label: 'Status', field: 'status' }
    ],
    'Donations': [
        { type: 'multi-select', label: 'Charity', field: 'charityName' },
        { type: 'number-range', label: 'Amount', field: 'amountRange' },
        { type: 'multi-select', label: 'Type', field: 'donationType' },
        { type: 'date-range', label: 'Date', field: 'dateRange' },
        { type: 'multi-select', label: 'Status', field: 'status' }
    ]
};

interface DocumentFiltersProps {
    type: DocumentType;
    filters: DocumentFilter;
    onFilterChange: (filters: DocumentFilter) => void;
    variant?: 'default' | 'toolbar';
    availableOptions?: Record<string, string[]>;
}

export const DocumentFilters: React.FC<DocumentFiltersProps> = ({
    type,
    filters,
    onFilterChange,
    variant = 'default',
    availableOptions = {}
}) => {
    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
    const [filterOptions, setFilterOptions] = useState<FilterOptions>({
        categories: [],
        payment_methods: [],
        statuses: [],
        vendors: []
    });

    useEffect(() => {
        // Fetch filter options from the backend
        const fetchOptions = async () => {
            try {
                const { data } = await apiClient.get<FilterOptions>('/options');
                setFilterOptions(data);
            } catch (error) {
                console.error('Error fetching filter options:', error);
            }
        };

        fetchOptions();
    }, []);

    const getOptionsForField = (field: string): string[] => {
        if (!availableOptions) return [];
        
        switch (field) {
            case 'category':
                return availableOptions.categories || [];
            case 'paymentMethod':
                return availableOptions.payment_methods || [];
            case 'status':
                return availableOptions.statuses || [];
            case 'vendor':
                return availableOptions.vendors || [];
            default:
                return [];
        }
    };

    const handleNumberRangeChange = (field: string, bound: 'min' | 'max', value: string) => {
        const numValue = value ? Number(value) : undefined;
        onFilterChange({
            ...filters,
            [field]: {
                ...(filters[field as keyof DocumentFilter] as any || {}),
                [bound]: numValue
            }
        });
    };

    const handleDateRangeChange = (field: string, bound: 'start' | 'end', value: string) => {
        onFilterChange({
            ...filters,
            [field]: {
                ...(filters[field as keyof DocumentFilter] as any || {}),
                [bound]: value || undefined
            }
        });
    };

    const handleMultiSelectChange = (field: string, values: string[]) => {
        onFilterChange({
            ...filters,
            [field]: values
        });
    };

    const handleRemoveFilter = (field: keyof DocumentFilter, value?: string) => {
        const newFilters = { ...filters };
        
        if (value && Array.isArray(newFilters[field])) {
            const currentValues = newFilters[field] as string[];
            newFilters[field] = currentValues.filter(v => v !== value) as any;
            if ((newFilters[field] as string[]).length === 0) {
                delete newFilters[field];
            }
        } else {
            delete newFilters[field];
        }
        onFilterChange(newFilters);
    };

    const handleResetFilters = () => {
        onFilterChange({
            type: type,
            dateRange: undefined,
            status: undefined,
            ...(type === 'Expenses' ? {
                vendor: undefined,
                category: undefined,
                amountRange: undefined,
                paymentMethod: undefined,
            } : {}),
            ...(type === 'W-2' ? {
                employer: undefined,
                wageRange: undefined,
            } : {}),
        } as DocumentFilter);
    };

    const renderActiveFilters = () => {
        return (
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 1 }}>
                {FILTER_CONFIG[type].map(field => {
                    const value = filters[field.field as keyof DocumentFilter];
                    if (!value) return null;

                    switch (field.type) {
                        case 'multi-select':
                            return (Array.isArray(value) ? value : []).map(v => (
                                <Chip
                                    key={`${field.field}-${v}`}
                                    label={`${field.label}: ${v}`}
                                    onDelete={() => handleRemoveFilter(field.field as keyof DocumentFilter, v)}
                                    size="small"
                                />
                            ));
                        case 'number-range': {
                            const range = value as { min?: number; max?: number };
                            if (!range.min && !range.max) return null;
                            return (
                                <Chip
                                    key={field.field}
                                    label={`${field.label}: ${range.min || '0'} - ${range.max || '∞'}`}
                                    onDelete={() => handleRemoveFilter(field.field as keyof DocumentFilter)}
                                    size="small"
                                />
                            );
                        }
                        case 'date-range': {
                            const dates = value as { start?: string; end?: string };
                            if (!dates.start && !dates.end) return null;
                            return (
                                <Chip
                                    key={field.field}
                                    label={`${field.label}: ${dates.start || '∞'} - ${dates.end || '∞'}`}
                                    onDelete={() => handleRemoveFilter(field.field as keyof DocumentFilter)}
                                    size="small"
                                />
                            );
                        }
                        default:
                            return null;
                    }
                })}
            </Box>
        );
    };

    const renderFilterField = (field: FilterField) => {
        const filterValue = filters[field.field as keyof DocumentFilter];

        switch (field.type) {
            case 'number-range': {
                const range = filterValue as { min?: number; max?: number } || {};
                return (
                    <Box sx={{ display: 'flex', gap: 2 }}>
                        <TextField
                            label={`Min ${field.label}`}
                            type="number"
                            size="small"
                            value={range.min || ''}
                            onChange={(e) => handleNumberRangeChange(field.field, 'min', e.target.value)}
                        />
                        <TextField
                            label={`Max ${field.label}`}
                            type="number"
                            size="small"
                            value={range.max || ''}
                            onChange={(e) => handleNumberRangeChange(field.field, 'max', e.target.value)}
                        />
                    </Box>
                );
            }

            case 'date-range': {
                const dates = filterValue as { start?: string; end?: string } || {};
                return (
                    <Box sx={{ display: 'flex', gap: 2 }}>
                        <TextField
                            label="Start Date"
                            type="date"
                            size="small"
                            InputLabelProps={{ shrink: true }}
                            value={dates.start || ''}
                            onChange={(e) => handleDateRangeChange(field.field, 'start', e.target.value)}
                        />
                        <TextField
                            label="End Date"
                            type="date"
                            size="small"
                            InputLabelProps={{ shrink: true }}
                            value={dates.end || ''}
                            onChange={(e) => handleDateRangeChange(field.field, 'end', e.target.value)}
                        />
                    </Box>
                );
            }

            case 'multi-select':
                return (
                    <FormControl size="small" sx={{ minWidth: 200 }}>
                        <InputLabel>{field.label}</InputLabel>
                        <Select
                            multiple
                            value={(filterValue as string[]) || []}
                            onChange={(e) => handleMultiSelectChange(field.field, e.target.value as string[])}
                            label={field.label}
                        >
                            {getOptionsForField(field.field).map((option) => (
                                <MenuItem key={option} value={option}>
                                    {option}
                                </MenuItem>
                            ))}
                        </Select>
                    </FormControl>
                );
        }
    };

    if (variant === 'toolbar') {
        return (
            <>
                <Button
                    startIcon={<TuneIcon />}
                    onClick={(e) => setAnchorEl(e.currentTarget)}
                    variant="outlined"
                    size="small"
                    endIcon={Object.keys(filters).length > 0 && 
                        <Chip 
                            label={Object.keys(filters).length} 
                            size="small" 
                            color="primary"
                        />
                    }
                >
                    Filters
                </Button>
                <Menu
                    anchorEl={anchorEl}
                    open={Boolean(anchorEl)}
                    onClose={() => setAnchorEl(null)}
                    PaperProps={{
                        sx: { width: 400, maxHeight: '80vh' }
                    }}
                >
                    <Box sx={{ p: 2 }}>
                        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                            {FILTER_CONFIG[type].map(field => (
                                <Box key={field.field}>
                                    {renderFilterField(field)}
                                </Box>
                            ))}
                        </Box>
                        {renderActiveFilters()}
                    </Box>
                </Menu>
            </>
        );
    }

    return (
        <Box sx={{ mb: 2 }}>
            <Accordion>
                <AccordionSummary
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                        bgcolor: 'background.default',
                        '&:hover': { bgcolor: 'action.hover' }
                    }}
                >
                    <Box sx={{ 
                        display: 'flex', 
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        width: '100%',
                        pr: 2
                    }}>
                        <Box sx={{ 
                            display: 'flex', 
                            alignItems: 'center', 
                            gap: 1 
                        }}>
                            <TuneIcon />
                            <Typography>Filters</Typography>
                        </Box>
                        
                        {Object.keys(filters).length > 0 && (
                            <Button
                                size="small"
                                startIcon={<RestartAltIcon />}
                                onClick={(e) => {
                                    e.stopPropagation();
                                    handleResetFilters();
                                }}
                                sx={{ ml: 2 }}
                            >
                                Reset Filters
                            </Button>
                        )}
                    </Box>
                </AccordionSummary>
                <AccordionDetails>
                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                        {FILTER_CONFIG[type].map(field => (
                            <Box key={field.field}>
                                {renderFilterField(field)}
                            </Box>
                        ))}
                    </Box>
                </AccordionDetails>
            </Accordion>
            {renderActiveFilters()}
        </Box>
    );
};

================
File: components/Documents/DocumentsFilters.tsx
================
import React from 'react';
import { 
    Box, 
    TextField, 
    Select, 
    MenuItem, 
    Button,
    InputLabel,
    FormControl,
    SelectChangeEvent,
} from '@mui/material';
import { DocumentStatus } from '@/types';

interface DocumentsFiltersProps {
    statusFilter: DocumentStatus;
    searchQuery: string;
    onStatusChange: (status: DocumentStatus) => void;
    onSearchChange: (query: string) => void;
    onReset: () => void;
}

export const DocumentsFilters: React.FC<DocumentsFiltersProps> = ({
    statusFilter,
    searchQuery,
    onStatusChange,
    onSearchChange,
    onReset,
}) => {
    const handleStatusChange = (event: SelectChangeEvent) => {
        onStatusChange(event.target.value as DocumentStatus);
    };

    return (
        <Box 
            sx={{ 
                display: 'flex', 
                gap: 2, 
                mb: 3,
                flexDirection: { xs: 'column', sm: 'row' },
                alignItems: { xs: 'stretch', sm: 'center' },
            }}
        >
            <FormControl 
                sx={{ 
                    minWidth: { xs: '100%', sm: 200 } 
                }}
            >
                <InputLabel id="status-filter-label">Status</InputLabel>
                <Select
                    labelId="status-filter-label"
                    value={statusFilter}
                    label="Status"
                    onChange={handleStatusChange}
                    size="small"
                >
                    <MenuItem value="all">All</MenuItem>
                    <MenuItem value="pending">Pending</MenuItem>
                    <MenuItem value="approved">Approved</MenuItem>
                </Select>
            </FormControl>

            <TextField
                placeholder="Search in Documents..."
                value={searchQuery}
                onChange={(e) => onSearchChange(e.target.value)}
                size="small"
                sx={{ 
                    flex: 1,
                    minWidth: { xs: '100%', sm: 300 }
                }}
            />

            <Button
                variant="outlined"
                onClick={onReset}
                sx={{ 
                    minWidth: { xs: '100%', sm: 'auto' }
                }}
            >
                Reset Filters
            </Button>
        </Box>
    );
};

================
File: components/Documents/DocumentsTable.tsx
================
import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Paper,
    IconButton,
    TableSortLabel,
    Box,
    Typography,
    Tooltip,
    CircularProgress,
    Checkbox,
    Alert,
    Snackbar,
    Fade,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogContentText,
    DialogActions,
    Button,
    Select,
    MenuItem,
    ClickAwayListener,
    SelectChangeEvent,
} from '@mui/material';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import EditIcon from '@mui/icons-material/Edit';
import VisibilityIcon from '@mui/icons-material/Visibility';
import DeleteIcon from '@mui/icons-material/Delete';
import { 
    DocumentType, 
    DocumentStatus, 
    Document,
    W2Document,
    Form1099Document,
    ExpenseDocument,
    DonationDocument,
    BaseDocument
} from '@/types';
import { documentsApi } from '../../lib/api/documents';
import { useRouter } from 'next/router';
import { ImageViewer } from '@/components/ImageViewer';
import { DocumentFilter, 
    W2Filter, 
    Form1099Filter, 
    ExpenseFilter, 
    DonationFilter 
} from '@/types/filters';
import { DocumentFilters } from './DocumentFilters';
import { useSearch } from '@/contexts/SearchContext';
import { EditableCell } from './EditableCell';
import { format, parse, isValid } from 'date-fns';
import { enUS } from 'date-fns/locale';

type ColumnId<T> = keyof T;

interface Column<T extends BaseDocument> {
  id: keyof T | 'actions' | 'category';
  label: string;
  minWidth?: number;
  align?: 'left' | 'right' | 'center';
  format?: (value: any) => string;
  editable?: boolean;
  editType?: 'text' | 'date' | 'amount' | 'select';
  options?: string[];
}

type DocumentColumns = {
  'W-2': Column<W2Document>[];
  '1099': Column<Form1099Document>[];
  'Expenses': Column<ExpenseDocument>[];
  'Donations': Column<DonationDocument>[];
};

const COLUMNS: DocumentColumns = {
  'W-2': [
    { id: 'employer', label: 'Employer', minWidth: 170 },
    { 
      id: 'wages',
      label: 'Wages',
      minWidth: 100,
      align: 'right',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { 
      id: 'fedWithholding',
      label: 'Fed Withholding',
      minWidth: 130,
      align: 'right',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { id: 'status', label: 'Status', minWidth: 100, align: 'center' }
  ],
  '1099': [
    { id: 'employer', label: 'Payer', minWidth: 170 },
    { 
      id: 'nonEmpCompensation',
      label: 'Amount',
      minWidth: 100,
      align: 'right',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { id: 'status', label: 'Status', minWidth: 100, align: 'center' }
  ],
  'Expenses': [
    { 
      id: 'vendor',
      label: 'Vendor',
      minWidth: 170,
      editable: true,
      editType: 'text'
    },
    { 
      id: 'amount',
      label: 'Amount',
      minWidth: 100,
      align: 'right',
      editable: true,
      editType: 'amount',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { 
      id: 'date',
      label: 'Date',
      minWidth: 100,
      editable: true,
      editType: 'date',
      format: (value: string) => new Date(value).toLocaleDateString()
    },
    { 
      id: 'payment_method',
      label: 'Payment Method',
      minWidth: 130,
      editable: true,
      editType: 'select',
      options: ['Credit Card', 'Debit Card', 'Cash', 'Check', 'Wire Transfer', 'Other']
    },
    { 
      id: 'category',
      label: 'Expense Type',
      minWidth: 150,
      editable: true,
      editType: 'select',
      options: []
    },
    { 
      id: 'status' as keyof ExpenseDocument,
      label: 'Status',
      minWidth: 100,
      align: 'center',
      editable: true,
      editType: 'select',
      options: [] // Will be populated from backend /options endpoint
    }
  ],
  'Donations': [
    { id: 'charityName', label: 'Charity', minWidth: 170 },
    { 
      id: 'amount',
      label: 'Amount',
      minWidth: 100,
      align: 'right',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { id: 'donationType', label: 'Type', minWidth: 100 },
    { id: 'date', label: 'Date', minWidth: 100 },
    { id: 'status', label: 'Status', minWidth: 100, align: 'center' }
  ],
};

interface DocumentsTableProps {
    type: DocumentType;
    filters: DocumentFilter;
    onFilterChange: (newFilters: DocumentFilter) => void;
}

// Add this type for sorting
type SortComparator = (a: Document, b: Document) => number;

// Add this helper function at the top of the file
const isValidDate = (dateStr: string) => {
    const date = new Date(dateStr);
    return date instanceof Date && !isNaN(date.getTime());
};

const TableToolbar = ({ 
    type,
    numSelected, 
    onSelectAll, 
    onDelete,
    filters,
    onFilterChange,
    availableOptions
}: { 
    type: DocumentType;
    numSelected: number;
    onSelectAll: (event: React.ChangeEvent<HTMLInputElement>) => void;
    onDelete: () => void;
    filters: DocumentFilter;
    onFilterChange: (filters: DocumentFilter) => void;
    availableOptions: Record<string, string[]>;
}) => (
    <Box
        sx={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            borderBottom: 1,
            borderColor: 'divider',
            bgcolor: numSelected > 0 ? 'action.selected' : 'background.paper',
            px: 2,
            py: 1,
        }}
    >
        {/* Left side: Selection and bulk actions */}
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <Checkbox
                indeterminate={numSelected > 0}
                checked={numSelected > 0}
                onChange={onSelectAll}
            />
            {numSelected > 0 ? (
                <>
                    <Typography>
                        {numSelected} selected
                    </Typography>
                    <Tooltip title="Delete">
                        <IconButton 
                            onClick={onDelete}
                            size="small"
                        >
                            <DeleteIcon />
                        </IconButton>
                    </Tooltip>
                </>
            ) : (
                <Typography variant="h6" component="div">
                    {type}
                </Typography>
            )}
        </Box>

        {/* Right side: Filters */}
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
            <DocumentFilters
                type={type}
                filters={filters}
                onFilterChange={onFilterChange}
                availableOptions={availableOptions}
                variant="toolbar" // New prop to render in compact mode
            />
        </Box>
    </Box>
);

interface DocumentData extends BaseDocument {
    id: number;
    type: DocumentType;
    status: DocumentStatus;
    uploadDate: string;
    image_path?: string;
    vendor?: string;
    amount?: number;
    date?: string;
    payment_method?: string;
    category?: string;
    // Add optional fields from other document types
    employer?: string;
    wages?: number;
    fedWithholding?: number;
    nonEmpCompensation?: number;
    charityName?: string;
    donationType?: string;
}

// First, add type guard functions at the top of the file
const isW2Document = (doc: DocumentData): doc is W2Document => {
    return doc.type === DocumentType.W2;
};

const isExpenseDocument = (doc: DocumentData): doc is ExpenseDocument => {
    return doc.type === DocumentType.EXPENSE;
};

const is1099Document = (doc: DocumentData): doc is Form1099Document => {
    return doc.type === DocumentType.FORM_1099;
};

const isDonationDocument = (doc: DocumentData): doc is DonationDocument => {
    return doc.type === DocumentType.DONATION;
};

export const DocumentsTable: React.FC<DocumentsTableProps> = ({
    type,
    filters,
    onFilterChange,
}) => {
    const router = useRouter();
    const [documents, setDocuments] = useState<DocumentData[]>([]);
    const [loading, setLoading] = useState(true);
    const [orderBy, setOrderBy] = useState<string>('');
    const [order, setOrder] = useState<'asc' | 'desc'>('asc');
    const [error, setError] = useState<string | null>(null);
    const [availableOptions, setAvailableOptions] = useState<Record<string, string[]>>({});
    const { searchQuery } = useSearch();
    const [selected, setSelected] = useState<number[]>([]);
    const [deleteSnackbar, setDeleteSnackbar] = useState({
        open: false,
        message: ''
    });
    const [showBulkDeleteConfirm, setShowBulkDeleteConfirm] = useState(false);
    const [isDeleting, setIsDeleting] = useState(false);
    const [bulkActionStatus, setBulkActionStatus] = useState<{
        show: boolean;
        message: string;
        type: 'success' | 'error';
    }>({ show: false, message: '', type: 'success' });
    const [columns, setColumns] = useState(() => ({
        'W-2': COLUMNS['W-2'],
        '1099': COLUMNS['1099'],
        'Expenses': COLUMNS['Expenses'],
        'Donations': COLUMNS['Donations']
    }));
    const [selectedImage, setSelectedImage] = useState<string | null>(null);

    const fetchDocuments = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
            const response = await documentsApi.getDocuments();
            if (!response?.data) {
                throw new Error('No data received from server');
            }
            setDocuments(response.data);
        } catch (error) {
            console.error('Error fetching documents:', error);
            setError('Failed to load documents. Please try again.');
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        // Fetch documents
        fetchDocuments();
        
        // Set default sorting
        if (type === 'Expenses') {
            setOrderBy('date');
            setOrder('desc');
        } else {
            setOrderBy('');
            setOrder('asc');
        }
    }, [type]); // Single effect for type changes

    useEffect(() => {
        if (documents.length > 0) {
            const options: Record<string, Set<string>> = {};
            
            documents.forEach(doc => {
                if (doc.type === 'Expenses') {
                    // Collect vendors
                    if (doc.vendor) {
                        options.vendor = options.vendor || new Set();
                        options.vendor.add(doc.vendor);
                    }
                    // Collect payment methods
                    if (doc.payment_method) {
                        options.paymentMethods = options.paymentMethods || new Set();
                        options.paymentMethods.add(doc.payment_method);
                    }
                    // Collect categories
                    if (doc.category) {
                        options.categories = options.categories || new Set();
                        options.categories.add(doc.category);
                    }
                }
                // Add similar collectors for other document types
            });

            // Convert Sets to arrays
            const finalOptions = Object.entries(options).reduce((acc, [key, value]) => {
                acc[key] = Array.from(value).sort();
                return acc;
            }, {} as Record<string, string[]>);

            setAvailableOptions(finalOptions);
        }
    }, [documents]);

    useEffect(() => {
        setSelected([]);
    }, [type]);

    useEffect(() => {
        const fetchOptions = async () => {
            try {
                const response = await fetch('/api/options');
                if (!response.ok) throw new Error('Failed to fetch options');
                const data = await response.json();
                
                // Update the columns with the fetched options
                setColumns(prev => ({
                    ...prev,
                    'Expenses': prev['Expenses'].map(column => {
                        if (column.id === 'category') {
                            return { ...column, options: data.categories || [] };
                        }
                        if (column.id === 'status') {
                            return { ...column, options: data.statuses || [] };
                        }
                        return column;
                    })
                }));
            } catch (error) {
                console.error('Error fetching options:', error);
            }
        };

        fetchOptions();
    }, []);

    // Remove or comment out this function since it's not implemented
    // const handleApprove = async (documentId: number) => {
    //     try {
    //         await documentsApi.approveDocument(documentId, type);
    //         await fetchDocuments();
    //     } catch (error) {
    //         console.error('Error approving document:', error);
    //     }
    // };

    const handleEdit = (documentId: number) => {
        // For now, just log the action
        console.log('Edit document:', documentId);
    };

    const handleSort = useCallback((columnId: string) => {
        const isAsc = orderBy === columnId && order === 'asc';
        setOrder(isAsc ? 'desc' : 'asc');
        setOrderBy(columnId);
    }, [orderBy, order]);

    // Then modify the getFilteredDocuments function to use type guards
    const getFilteredDocuments = useCallback((docs: DocumentData[]) => {
        if (!Array.isArray(docs)) return [];
        
        return docs.filter((doc) => {
            if (doc.type !== type) return false;

            switch (doc.type) {
                case DocumentType.W2: {
                    if (!isW2Document(doc)) return false;
                    const w2Filter = filters as W2Filter;
                    
                    if (w2Filter.employer?.length && !w2Filter.employer.includes(doc.employer)) return false;
                    if (w2Filter.wageRange?.min && doc.wages < w2Filter.wageRange.min) return false;
                    if (w2Filter.wageRange?.max && doc.wages > w2Filter.wageRange.max) return false;
                    break;
                }
                case DocumentType.EXPENSE: {
                    if (!isExpenseDocument(doc)) return false;
                    const expenseFilter = filters as ExpenseFilter;
                    
                    if (expenseFilter.vendor?.length && !expenseFilter.vendor.includes(doc.vendor)) return false;
                    if (expenseFilter.amountRange?.min && doc.amount < expenseFilter.amountRange.min) return false;
                    if (expenseFilter.amountRange?.max && doc.amount > expenseFilter.amountRange.max) return false;
                    if (expenseFilter.paymentMethod?.length && !expenseFilter.paymentMethod.includes(doc.payment_method)) return false;
                    if (expenseFilter.category?.length && !expenseFilter.category.includes(doc.category)) return false;
                    break;
                }
                // ... other cases
            }
            return true;
        });
    }, [type, filters]);

    // Add sorting logic
    const getSortedDocuments = useCallback(() => {
        const filtered = getFilteredDocuments(documents);
        if (!orderBy || !Array.isArray(filtered)) return filtered;

        return [...filtered].sort((a, b) => {
            let aValue = a[orderBy as keyof typeof a];
            let bValue = b[orderBy as keyof typeof b];

            // Handle special cases for expense documents
            if (a.type === 'Expenses' && b.type === 'Expenses') {
                // Handle amount sorting
                if (orderBy === 'amount') {
                    aValue = typeof aValue === 'string' 
                        ? parseFloat(aValue.replace(/[^0-9.-]+/g, ''))
                        : aValue;
                    bValue = typeof bValue === 'string' 
                        ? parseFloat(bValue.replace(/[^0-9.-]+/g, ''))
                        : bValue;
                }

                // Handle date sorting
                if (orderBy === 'date') {
                    const aValid = isValidDate(aValue as string);
                    const bValid = isValidDate(bValue as string);

                    // If both dates are invalid, maintain their original order
                    if (!aValid && !bValid) return 0;

                    // In ascending order: invalid dates go to the end
                    // In descending order: invalid dates go to the beginning
                    if (!aValid) return order === 'asc' ? 1 : -1;
                    if (!bValid) return order === 'asc' ? -1 : 1;

                    // Both dates are valid, compare them
                    const aTime = new Date(aValue as string).getTime();
                    const bTime = new Date(bValue as string).getTime();
                    return order === 'asc' ? aTime - bTime : bTime - aTime;
                }
            }

            // Handle null/undefined values
            if (aValue === null || aValue === undefined) return 1;
            if (bValue === null || bValue === undefined) return -1;
            if (aValue === bValue) return 0;

            // Handle numeric values
            if (typeof aValue === 'number' && typeof bValue === 'number') {
                return order === 'asc' ? aValue - bValue : bValue - aValue;
            }

            // Handle string values
            const aString = String(aValue).toLowerCase();
            const bString = String(bValue).toLowerCase();
            
            return order === 'asc' 
                ? aString.localeCompare(bString)
                : bString.localeCompare(aString);
        });
    }, [documents, getFilteredDocuments, orderBy, order]);

    const renderActions = (document: DocumentData) => (
        <Box sx={{ display: 'flex', gap: 1, justifyContent: 'flex-end' }}>
            <Tooltip title="View Receipt">
                <IconButton
                    size="small"
                    onClick={() => document.image_path && setSelectedImage(document.image_path)}
                    sx={{ 
                        color: 'text.secondary',
                        '&:hover': { color: 'primary.main' }
                    }}
                >
                    <VisibilityIcon fontSize="small" />
                </IconButton>
            </Tooltip>
            <Tooltip title="Delete">
                <IconButton
                    size="small"
                    onClick={() => handleDelete(document.id)}
                    sx={{ 
                        color: 'text.secondary',
                        '&:hover': { color: 'error.main' }
                    }}
                >
                    <DeleteIcon fontSize="small" />
                </IconButton>
            </Tooltip>
        </Box>
    );

    const filteredDocuments = useMemo(() => 
        getFilteredDocuments(documents), 
        [documents, getFilteredDocuments]
    );

    const sortedDocuments = useMemo(() => 
        getSortedDocuments(), 
        [getFilteredDocuments, orderBy, order, getSortedDocuments]
    );

    const handleSelectAllClick = (event: React.ChangeEvent<HTMLInputElement>) => {
        if (event.target.checked) {
            const newSelected = documents.map(doc => doc.id);
            setSelected(newSelected);
            return;
        }
        setSelected([]);
    };

    const handleClick = (id: number) => {
        const selectedIndex = selected.indexOf(id);
        let newSelected: number[] = [];

        if (selectedIndex === -1) {
            newSelected = newSelected.concat(selected, id);
        } else if (selectedIndex === 0) {
            newSelected = newSelected.concat(selected.slice(1));
        } else if (selectedIndex === selected.length - 1) {
            newSelected = newSelected.concat(selected.slice(0, -1));
        } else if (selectedIndex > 0) {
            newSelected = newSelected.concat(
                selected.slice(0, selectedIndex),
                selected.slice(selectedIndex + 1)
            );
        }

        setSelected(newSelected);
    };

    const handleBulkDelete = async () => {
        if (!selected.length) return;
        
        console.log(`[DocumentsTable] Starting bulk delete for ${selected.length} documents:`, selected);
        setIsDeleting(true);
        try {
            await documentsApi.deleteDocuments(selected);
            console.log('[DocumentsTable] Bulk delete API call successful');
            
            // Only clear selection and refresh if delete was successful
            setSelected([]);
            await fetchDocuments();
            
            setBulkActionStatus({
                show: true,
                message: 'Successfully deleted selected items',
                type: 'success'
            });
            setShowBulkDeleteConfirm(false);
        } catch (error) {
            console.error('[DocumentsTable] Bulk delete error:', error);
            setBulkActionStatus({
                show: true,
                message: error instanceof Error ? error.message : 'Failed to delete selected items',
                type: 'error'
            });
        } finally {
            setIsDeleting(false);
        }
    };

    // Modify the renderCell function to use type guards
    const renderCell = (document: DocumentData, column: Column<DocumentData>) => {
        if (isW2Document(document)) {
            return renderW2Cell(document, column as Column<W2Document>);
        }
        if (isExpenseDocument(document)) {
            return renderExpenseCell(document, column as Column<ExpenseDocument>);
        }
        if (is1099Document(document)) {
            return render1099Cell(document, column as Column<Form1099Document>);
        }
        if (isDonationDocument(document)) {
            return renderDonationCell(document, column as Column<DonationDocument>);
        }
        return null;
    };

    const handleUpdateField = async (documentId: number, field: string, value: any) => {
        try {
            console.log('[DocumentsTable] handleUpdateField: Starting update:', {
                documentId,
                field,
                value,
                valueType: typeof value
            });
            
            // Format the value based on field type
            let formattedValue = value;
            if (field === 'amount') {
                formattedValue = typeof value === 'string' 
                    ? parseFloat(value.replace(/[^\d.-]/g, ''))
                    : Number(value);
                console.log('[DocumentsTable] Formatted amount value:', formattedValue);
                
                // Validate the number
                if (isNaN(formattedValue)) {
                    throw new Error('Invalid amount value');
                }
            } else if (field === 'status') {
                // Ensure proper case for status values
                formattedValue = value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
                console.log('[DocumentsTable] Formatted status value:', formattedValue);
            }
            
            console.log('[DocumentsTable] Sending update with formatted value:', {
                field,
                formattedValue,
                formattedValueType: typeof formattedValue
            });
            
            // Optimistic update
            setDocuments(prevDocs =>
                prevDocs.map(doc =>
                    doc.id === documentId 
                        ? { ...doc, [field]: formattedValue }
                        : doc
                )
            );
            
            const updates = { [field]: formattedValue };
            const updatedDoc = await documentsApi.updateDocument(documentId, updates);
            
            console.log('[DocumentsTable] Received updated document:', updatedDoc);
            
            // Still fetch to ensure consistency with server
            await fetchDocuments();
        } catch (error) {
            console.error('[DocumentsTable] Update failed:', {
                error,
                documentId,
                field,
                value
            });
            // Revert optimistic update on error
            await fetchDocuments();
            throw error;
        }
    };

    const handleDelete = async (documentId: number) => {
        console.log(`[DocumentsTable] Initiating delete for document: ${documentId}`);
        try {
            await documentsApi.deleteDocument(documentId);
            console.log(`[DocumentsTable] Delete API call successful for document: ${documentId}`);
            // Refresh the documents list after successful delete
            await fetchDocuments();
            setDeleteSnackbar({
                open: true,
                message: 'Document deleted successfully'
            });
        } catch (error) {
            console.error('[DocumentsTable] Error in delete handler:', error);
            setDeleteSnackbar({
                open: true,
                message: error instanceof Error 
                    ? error.message 
                    : 'Failed to delete document. Please try again.'
            });
        } finally {
            setLoading(false);
        }
    };

    // Add these render functions
    const renderExpenseCell = (doc: ExpenseDocument, column: Column<ExpenseDocument>) => {
        if (column.id === 'actions') {
            return renderActions(doc);
        }
        
        const value = doc[column.id];
        if (column.editable) {
            return (
                <EditableCell
                    value={value}
                    type={column.editType || 'text'}
                    options={column.options}
                    onSave={async (newValue) => {
                        await handleUpdateField(doc.id, column.id as string, newValue);
                    }}
                    format={column.format}
                    align={column.align}
                />
            );
        }
        
        return column.format ? column.format(value) : value;
    };

    // Similar functions for other document types
    const renderW2Cell = (doc: W2Document, column: Column<W2Document>) => {
        // Similar implementation
    };

    const render1099Cell = (doc: Form1099Document, column: Column<Form1099Document>) => {
        // Similar implementation
    };

    const renderDonationCell = (doc: DonationDocument, column: Column<DonationDocument>) => {
        // Similar implementation
    };

    if (loading) {
        return (
            <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
                <CircularProgress />
            </Box>
        );
    }

    if (error) {
        return (
            <Paper 
                variant="outlined" 
                sx={{ 
                    p: 4, 
                    textAlign: 'center',
                    color: 'error.main'
                }}
            >
                <Typography>{error}</Typography>
            </Paper>
        );
    }

    if (documents.length === 0) {
        return (
            <Paper 
                variant="outlined" 
                sx={{ 
                    p: 4, 
                    textAlign: 'center',
                    color: 'text.secondary'
                }}
            >
                <Typography>
                    No {type} documents found
                </Typography>
            </Paper>
        );
    }

    return (
        <>
            <DocumentFilters
                type={type}
                filters={filters}
                onFilterChange={onFilterChange}
                availableOptions={availableOptions}
            />
            <Paper>
                <TableToolbar 
                    type={type}
                    numSelected={selected.length}
                    onSelectAll={handleSelectAllClick}
                    onDelete={handleBulkDelete}
                    filters={filters}
                    onFilterChange={onFilterChange}
                    availableOptions={availableOptions}
                />
                <TableContainer>
                    <Table stickyHeader size="small">
                        <TableHead>
                            <TableRow>
                                <TableCell padding="checkbox" />
                                {columns[type].map((column) => (
                                    <TableCell
                                        key={column.id}
                                        align={column.align}
                                        style={{ minWidth: column.minWidth }}
                                    >
                                        <TableSortLabel
                                            active={orderBy === column.id}
                                            direction={orderBy === column.id ? order : 'asc'}
                                            onClick={() => handleSort(column.id)}
                                            sx={{
                                                '& .MuiTableSortLabel-icon': {
                                                    opacity: orderBy === column.id ? 1 : 0.5
                                                }
                                            }}
                                        >
                                            {column.label}
                                        </TableSortLabel>
                                    </TableCell>
                                ))}
                                <TableCell align="right">Actions</TableCell>
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            {sortedDocuments.map((document) => (
                                <TableRow 
                                    hover 
                                    key={document.id}
                                    selected={selected.includes(document.id)}
                                    sx={{ 
                                        '&:hover': {
                                            bgcolor: 'action.hover',
                                        }
                                    }}
                                >
                                    <TableCell padding="checkbox">
                                        <Checkbox
                                            checked={selected.includes(document.id)}
                                            onChange={() => handleClick(document.id)}
                                        />
                                    </TableCell>
                                    {columns[type].map((column) => renderCell(document, column))}
                                    <TableCell align="right">
                                        {renderActions(document)}
                                    </TableCell>
                                </TableRow>
                            ))}
                        </TableBody>
                    </Table>
                </TableContainer>
            </Paper>

            <Snackbar
                open={deleteSnackbar.open}
                autoHideDuration={6000}
                onClose={() => setDeleteSnackbar({ ...deleteSnackbar, open: false })}
                message={deleteSnackbar.message}
            />

            <Dialog
                open={showBulkDeleteConfirm}
                onClose={() => setShowBulkDeleteConfirm(false)}
            >
                <DialogTitle>Confirm Delete</DialogTitle>
                <DialogContent>
                    <DialogContentText>
                        Are you sure you want to delete {selected.length} selected items?
                    </DialogContentText>
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setShowBulkDeleteConfirm(false)}>
                        Cancel
                    </Button>
                    <Button 
                        onClick={handleBulkDelete}
                        color="error"
                        disabled={isDeleting}
                    >
                        {isDeleting ? 'Deleting...' : 'Delete'}
                    </Button>
                </DialogActions>
            </Dialog>

            <Snackbar
                open={bulkActionStatus.show}
                autoHideDuration={6000}
                onClose={() => setBulkActionStatus(prev => ({ ...prev, show: false }))}
            >
                <Alert 
                    severity={bulkActionStatus.type}
                    onClose={() => setBulkActionStatus(prev => ({ ...prev, show: false }))}
                >
                    {bulkActionStatus.message}
                </Alert>
            </Snackbar>

            {selectedImage && (
                <ImageViewer
                    imagePath={selectedImage}
                    onClose={() => setSelectedImage(null)}
                />
            )}
        </>
    );
};

================
File: components/Documents/DocumentsTabs.tsx
================
import React from 'react';
import { Tabs, Tab, Box } from '@mui/material';
import { DocumentType } from '@/types';

interface DocumentsTabsProps {
    activeTab: DocumentType;
    onTabChange: (tab: DocumentType) => void;
}

const TABS: { value: DocumentType; label: string }[] = [
    { value: 'W-2', label: 'W-2' },
    { value: '1099', label: '1099' },
    { value: 'Expenses', label: 'Expenses' },
    { value: 'Donations', label: 'Donations' },
];

export const DocumentsTabs: React.FC<DocumentsTabsProps> = ({ 
    activeTab, 
    onTabChange 
}) => {
    return (
        <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
            <Tabs 
                value={activeTab}
                onChange={(_, newValue) => onTabChange(newValue)}
                variant="scrollable"
                scrollButtons="auto"
                aria-label="document type tabs"
                sx={{
                    '& .MuiTab-root': {
                        fontSize: '1rem',
                        fontWeight: 600,
                        textTransform: 'none',
                        minWidth: 100,
                    }
                }}
            >
                {TABS.map(tab => (
                    <Tab 
                        key={tab.value}
                        value={tab.value}
                        label={tab.label}
                        id={`tab-${tab.value}`}
                        aria-controls={`tabpanel-${tab.value}`}
                    />
                ))}
            </Tabs>
        </Box>
    );
};

================
File: components/Documents/DocumentsView.tsx
================
import React from 'react';
import { DocumentType } from '@/types';
import { 
    ExpenseDocumentTable,
    W2DocumentTable,
    Form1099DocumentTable,
    DonationDocumentTable 
} from './Tables';
import { Box } from '@mui/material';

interface DocumentsViewProps {
    activeTab: DocumentType;
    filters: any;
    onFilterChange: (filters: any) => void;
}

export const DocumentsView: React.FC<DocumentsViewProps> = ({ 
    activeTab,
    filters,
    onFilterChange
}) => {
    const renderTable = () => {
        switch (activeTab) {
            case DocumentType.EXPENSE:
                return (
                    <ExpenseDocumentTable 
                        filters={filters}
                        onFilterChange={onFilterChange}
                    />
                );
            case DocumentType.W2:
                return (
                    <W2DocumentTable 
                        filters={filters}
                        onFilterChange={onFilterChange}
                    />
                );
            case DocumentType.FORM_1099:
                return (
                    <Form1099DocumentTable 
                        filters={filters}
                        onFilterChange={onFilterChange}
                    />
                );
            case DocumentType.DONATION:
                return (
                    <DonationDocumentTable 
                        filters={filters}
                        onFilterChange={onFilterChange}
                    />
                );
            default:
                return null;
        }
    };

    return (
        <Box sx={{ width: '100%' }}>
            {renderTable()}
        </Box>
    );
};

================
File: components/Documents/DocumentUploadArea.tsx
================
import React, { useCallback, useState } from 'react';
import { Box, Typography, LinearProgress, Alert } from '@mui/material';
import { useDropzone } from 'react-dropzone';
import CloudUploadIcon from '@mui/icons-material/CloudUpload';
import { DocumentType } from '@/types';
import { documentsApi } from '@/lib/api/documents';

interface DocumentUploadAreaProps {
    activeTab: DocumentType;
    onUploadComplete?: () => void;
}

export const DocumentUploadArea: React.FC<DocumentUploadAreaProps> = ({ 
    activeTab,
    onUploadComplete 
}) => {
    const [isUploading, setIsUploading] = useState(false);
    const [uploadError, setUploadError] = useState<string | null>(null);

    const onDrop = useCallback(async (acceptedFiles: File[]) => {
        if (acceptedFiles.length === 0) return;

        setIsUploading(true);
        setUploadError(null);

        try {
            const file = acceptedFiles[0];
            await documentsApi.uploadDocument(file, activeTab);
            if (onUploadComplete) {
                onUploadComplete();
            }
        } catch (error) {
            setUploadError('Failed to upload document. Please try again.');
            console.error('Upload error:', error);
        } finally {
            setIsUploading(false);
        }
    }, [activeTab, onUploadComplete]);

    const { getRootProps, getInputProps, isDragActive } = useDropzone({
        onDrop,
        accept: {
            'image/jpeg': ['.jpg', '.jpeg'],
            'image/png': ['.png'],
            'application/pdf': ['.pdf']
        },
        multiple: false,
        disabled: isUploading
    });

    return (
        <Box 
            {...getRootProps()}
            sx={{
                p: 3,
                mb: 3,
                border: '2px dashed',
                borderColor: theme => 
                    isDragActive 
                        ? 'primary.main' 
                        : uploadError 
                            ? 'error.main' 
                            : 'divider',
                borderRadius: 1,
                bgcolor: theme =>
                    isDragActive
                        ? 'primary.light'
                        : uploadError
                            ? 'error.light'
                            : 'background.default',
                cursor: isUploading ? 'wait' : 'pointer',
                transition: 'all 0.2s ease',
                textAlign: 'center',
                position: 'relative'
            }}
        >
            <input {...getInputProps()} />

            {isUploading && (
                <LinearProgress 
                    sx={{ 
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        right: 0,
                        borderTopLeftRadius: 'inherit',
                        borderTopRightRadius: 'inherit'
                    }}
                />
            )}

            <Box sx={{ 
                display: 'flex', 
                flexDirection: 'column', 
                alignItems: 'center',
                gap: 2
            }}>
                <CloudUploadIcon 
                    sx={{ 
                        fontSize: 48,
                        color: theme => 
                            isDragActive 
                                ? 'primary.main' 
                                : 'text.secondary'
                    }} 
                />
                
                <Typography variant="h6" component="div">
                    {isDragActive
                        ? `Drop your ${activeTab} document here`
                        : isUploading
                            ? 'Uploading...'
                            : `Drag and drop your ${activeTab} document here`}
                </Typography>

                <Typography variant="body2" color="text.secondary">
                    or click to select files (PDF, JPEG, PNG)
                </Typography>
            </Box>

            {uploadError && (
                <Alert 
                    severity="error" 
                    sx={{ mt: 2 }}
                    onClose={() => setUploadError(null)}
                >
                    {uploadError}
                </Alert>
            )}
        </Box>
    );
};

================
File: components/Documents/DocumentUploadFab.tsx
================
import React, { useState } from 'react';
import { 
    Fab, 
    Dialog,
    DialogTitle,
    DialogContent,
    IconButton,
    Box,
    useTheme,
    useMediaQuery
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import CloseIcon from '@mui/icons-material/Close';
import { DocumentUploadArea } from './DocumentUploadArea';
import { DocumentType } from '@/types';

export const DocumentUploadFab: React.FC = () => {
    const [isOpen, setIsOpen] = useState(false);
    const theme = useTheme();
    const fullScreen = useMediaQuery(theme.breakpoints.down('sm'));

    return (
        <>
            <Fab
                color="primary"
                aria-label="upload document"
                onClick={() => setIsOpen(true)}
                sx={{
                    position: 'fixed',
                    bottom: 24,
                    right: 24,
                }}
            >
                <AddIcon />
            </Fab>

            <Dialog
                open={isOpen}
                onClose={() => setIsOpen(false)}
                fullScreen={fullScreen}
                maxWidth="md"
                fullWidth
            >
                <DialogTitle sx={{ 
                    m: 0, 
                    p: 2, 
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                }}>
                    Upload Document
                    <IconButton
                        aria-label="close"
                        onClick={() => setIsOpen(false)}
                        sx={{ color: 'text.secondary' }}
                    >
                        <CloseIcon />
                    </IconButton>
                </DialogTitle>
                <DialogContent>
                    <Box sx={{ pt: 2 }}>
                        <DocumentUploadArea activeTab={'W-2' as DocumentType} />
                    </Box>
                </DialogContent>
            </Dialog>
        </>
    );
};

================
File: components/Documents/EditableCell.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import {
  TextField,
  TableCell,
  Select,
  MenuItem,
  InputAdornment,
  Box,
  SelectChangeEvent,
} from '@mui/material';
import { useClickAway } from '@/hooks/useClickAway';

interface EditableCellProps {
  value: string | number | null;
  type: 'text' | 'date' | 'amount' | 'select';
  onSave: (newValue: string) => Promise<void>;
  options?: string[];
  disabled?: boolean;
  align?: 'left' | 'right' | 'center';
  format?: (value: any) => string;
}

export const EditableCell: React.FC<EditableCellProps> = ({
  value,
  type,
  onSave,
  options = [],
  disabled = false,
  align = 'left',
  format: formatValue,
}) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState('');
  const [error, setError] = useState<string | null>(null);
  const cellRef = useRef<HTMLTableCellElement>(null);

  const exitEditMode = () => {
    console.log('EditableCell: Exiting edit mode:', { 
      type, 
      value: editValue,
      isEditing,
      timestamp: new Date().getTime()
    });
    setIsEditing(false);
    setEditValue(value?.toString() ?? '');
    setError(null);
  };

  const handleSave = async (event: MouseEvent | TouchEvent) => {
    console.log('EditableCell: handleSave called:', { 
      type, 
      value: editValue,
      isEditing,
      eventType: event.type,
      timestamp: new Date().getTime()
    });
    
    if (!isEditing) return;

    try {
      if (type !== 'select') {
        console.log('EditableCell: Saving non-select value:', { type, value: editValue });
        await onSave(editValue);
        console.log('EditableCell: Save successful:', { type, value: editValue });
      }
      setError(null);
    } catch (err) {
      console.error('EditableCell.handleSave: Error saving value:', {
        error: err,
        type,
        value: editValue
      });
      setError(err instanceof Error ? err.message : 'An error occurred');
      return;
    } finally {
      exitEditMode();
    }
  };

  const listenClickAway = useClickAway(cellRef, (event) => {
    console.log('EditableCell: Click away detected:', { 
      type, 
      value: editValue,
      isEditing,
      eventType: event.type,
      target: (event.target as HTMLElement).tagName,
      targetClass: (event.target as HTMLElement).className,
      timestamp: new Date().getTime()
    });
    handleSave(event);
  });

  useEffect(() => {
    setEditValue(value?.toString() ?? '');
  }, [value]);

  const handleClick = (event: React.MouseEvent) => {
    console.log('EditableCell: Cell clicked:', {
      type,
      value,
      isEditing,
      timestamp: new Date().getTime()
    });
    
    event.stopPropagation();
    if (!disabled) {
      console.log('EditableCell: Starting edit mode:', { type, value });
      setIsEditing(true);
      listenClickAway(true);
    }
  };

  const handleTextChange = (
    event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    event.stopPropagation();
    setEditValue(event.target.value);
  };

  const handleSelectChange = (
    event: SelectChangeEvent<string>
  ) => {
    event.stopPropagation();
    const newValue = event.target.value;
    setEditValue(newValue);
    
    // Select-specific handling
    onSave(newValue)
        .then(() => {
            setError(null);
            exitEditMode();
        })
        .catch((err) => {
            setError(err instanceof Error ? err.message : 'An error occurred');
        });
  };

  if (!isEditing) {
    return (
      <TableCell
        ref={cellRef}
        align={align}
        onClick={handleClick}
        sx={{ 
          cursor: disabled ? 'default' : 'pointer',
          padding: '16px',
          '&:hover': {
            backgroundColor: disabled ? 'transparent' : 'action.hover',
          }
        }}
      >
        {formatValue ? formatValue(value) : value}
      </TableCell>
    );
  }

  return (
    <TableCell 
      ref={cellRef}
      align={align} 
      padding="none"
      sx={{
        position: 'relative',
        '& .MuiInputBase-root': {
          backgroundColor: 'background.paper',
        }
      }}
    >
      <Box sx={{ p: 1 }}>
        {type === 'select' ? (
          <Select
            value={editValue}
            onChange={handleSelectChange}
            onKeyDown={(e) => {
              if (e.key === 'Escape') {
                e.preventDefault();
                exitEditMode();
              }
            }}
            size="small"
            fullWidth
            open={isEditing}
            sx={{ backgroundColor: 'background.paper' }}
          >
            {options.map((option) => (
              <MenuItem 
                key={option} 
                value={option}
                onClick={(e) => {
                  console.log('EditableCell: MenuItem clicked:', { 
                    option, 
                    type,
                    currentValue: editValue,
                    isEditing,
                    timestamp: new Date().getTime()
                  });
                  e.stopPropagation();
                }}
              >
                {option}
              </MenuItem>
            ))}
          </Select>
        ) : (
          <TextField
            value={editValue}
            onChange={handleTextChange}
            error={!!error}
            helperText={error}
            size="small"
            fullWidth
            type={type}
            sx={{ backgroundColor: 'background.paper' }}
          />
        )}
      </Box>
    </TableCell>
  );
};

================
File: components/Documents/ExpenseFilters.tsx
================
import React, { useState, useEffect } from 'react';
import {
    Box,
    Accordion,
    AccordionSummary,
    AccordionDetails,
    Typography,
    TextField,
    Select,
    MenuItem,
    FormControl,
    InputLabel,
    Chip,
    IconButton,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import FilterListIcon from '@mui/icons-material/FilterList';
import CloseIcon from '@mui/icons-material/Close';
import apiClient from '@/services/apiClient';

export interface ExpenseFilter {
    vendor?: string[];
    amountRange?: {
        min?: number;
        max?: number;
    };
    dateRange?: {
        start?: string;
        end?: string;
    };
    paymentMethods?: string[];
    categories?: string[];
    status?: string[];
}

interface FilterOptions {
    categories: string[];
    payment_methods: string[];
    statuses: string[];
    vendors: string[];
}

interface ExpenseFiltersProps {
    filters: ExpenseFilter;
    onFilterChange: (filters: ExpenseFilter) => void;
}

interface FilterState {
    vendor: string;
    expenseType: string;
    payment_method: string;
    status: string;
    date_range: DateRange;
}

export const ExpenseFilters: React.FC<ExpenseFiltersProps> = ({
    filters,
    onFilterChange,
}) => {
    const [filterOptions, setFilterOptions] = useState<FilterOptions>({
        categories: [],
        payment_methods: [],
        statuses: [],
        vendors: []
    });

    useEffect(() => {
        const fetchOptions = async () => {
            try {
                const { data } = await apiClient.get<FilterOptions>('/options');
                setFilterOptions(data);
            } catch (error) {
                console.error('Error fetching filter options:', error);
            }
        };

        fetchOptions();
    }, []);

    const handleRemoveFilter = (type: keyof ExpenseFilter, value?: string) => {
        const newFilters = { ...filters };
        if (value && Array.isArray(newFilters[type])) {
            newFilters[type] = (newFilters[type] as string[]).filter(v => v !== value);
            if ((newFilters[type] as string[]).length === 0) {
                delete newFilters[type];
            }
        } else {
            delete newFilters[type];
        }
        onFilterChange(newFilters);
    };

    return (
        <Box sx={{ mb: 2 }}>
            <Accordion>
                <AccordionSummary
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                        bgcolor: 'background.default',
                        '&:hover': { bgcolor: 'action.hover' }
                    }}
                >
                    <Box sx={{ 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: 1 
                    }}>
                        <FilterListIcon />
                        <Typography>Filters</Typography>
                    </Box>
                </AccordionSummary>
                <AccordionDetails>
                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                        {/* Amount Range */}
                        <Box sx={{ display: 'flex', gap: 2 }}>
                            <TextField
                                label="Min Amount"
                                type="number"
                                size="small"
                                value={filters.amountRange?.min || ''}
                                onChange={(e) => onFilterChange({
                                    ...filters,
                                    amountRange: {
                                        ...filters.amountRange,
                                        min: e.target.value ? Number(e.target.value) : undefined
                                    }
                                })}
                            />
                            <TextField
                                label="Max Amount"
                                type="number"
                                size="small"
                                value={filters.amountRange?.max || ''}
                                onChange={(e) => onFilterChange({
                                    ...filters,
                                    amountRange: {
                                        ...filters.amountRange,
                                        max: e.target.value ? Number(e.target.value) : undefined
                                    }
                                })}
                            />
                        </Box>

                        {/* Date Range */}
                        <Box sx={{ display: 'flex', gap: 2 }}>
                            <TextField
                                label="Start Date"
                                type="date"
                                size="small"
                                InputLabelProps={{ shrink: true }}
                                value={filters.dateRange?.start || ''}
                                onChange={(e) => onFilterChange({
                                    ...filters,
                                    dateRange: {
                                        ...filters.dateRange,
                                        start: e.target.value || undefined
                                    }
                                })}
                            />
                            <TextField
                                label="End Date"
                                type="date"
                                size="small"
                                InputLabelProps={{ shrink: true }}
                                value={filters.dateRange?.end || ''}
                                onChange={(e) => onFilterChange({
                                    ...filters,
                                    dateRange: {
                                        ...filters.dateRange,
                                        end: e.target.value || undefined
                                    }
                                })}
                            />
                        </Box>

                        {/* Multi-select filters */}
                        <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
                            {/* Vendor Select */}
                            <FormControl size="small" sx={{ minWidth: 200 }}>
                                <InputLabel>Vendor</InputLabel>
                                <Select
                                    multiple
                                    value={filters.vendor || []}
                                    onChange={(e) => onFilterChange({
                                        ...filters,
                                        vendor: e.target.value as string[]
                                    })}
                                    label="Vendor"
                                >
                                    {filterOptions.vendors.map((vendor) => (
                                        <MenuItem key={vendor} value={vendor}>
                                            {vendor}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>

                            {/* Payment Method Select */}
                            <FormControl size="small" sx={{ minWidth: 200 }}>
                                <InputLabel>Payment Method</InputLabel>
                                <Select
                                    multiple
                                    value={filters.paymentMethods || []}
                                    onChange={(e) => onFilterChange({
                                        ...filters,
                                        paymentMethods: e.target.value as string[]
                                    })}
                                    label="Payment Method"
                                >
                                    {filterOptions.payment_methods.map((method) => (
                                        <MenuItem key={method} value={method}>
                                            {method}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>

                            {/* Category Select */}
                            <FormControl size="small" sx={{ minWidth: 200 }}>
                                <InputLabel>Category</InputLabel>
                                <Select
                                    multiple
                                    value={filters.categories || []}
                                    onChange={(e) => onFilterChange({
                                        ...filters,
                                        categories: e.target.value as string[]
                                    })}
                                    label="Category"
                                >
                                    {filterOptions.categories.map((category) => (
                                        <MenuItem key={category} value={category}>
                                            {category}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>

                            {/* Status Select */}
                            <FormControl size="small" sx={{ minWidth: 200 }}>
                                <InputLabel>Status</InputLabel>
                                <Select
                                    multiple
                                    value={filters.status || []}
                                    onChange={(e) => onFilterChange({
                                        ...filters,
                                        status: e.target.value as string[]
                                    })}
                                    label="Status"
                                >
                                    {filterOptions.statuses.map((status) => (
                                        <MenuItem key={status} value={status}>
                                            {status}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        </Box>
                    </Box>
                </AccordionDetails>
            </Accordion>

            {/* Active Filters Display */}
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 1 }}>
                {Object.entries(filters).map(([key, value]) => {
                    if (Array.isArray(value)) {
                        return value.map((v) => (
                            <Chip
                                key={`${key}-${v}`}
                                label={`${key}: ${v}`}
                                onDelete={() => handleRemoveFilter(key as keyof ExpenseFilter, v)}
                                size="small"
                            />
                        ));
                    }
                    if (key === 'amountRange' && value) {
                        const { min, max } = value;
                        if (min || max) {
                            return (
                                <Chip
                                    key="amount"
                                    label={`Amount: ${min || '0'} - ${max || '∞'}`}
                                    onDelete={() => handleRemoveFilter('amountRange')}
                                    size="small"
                                />
                            );
                        }
                    }
                    if (key === 'dateRange' && value) {
                        const { start, end } = value;
                        if (start || end) {
                            return (
                                <Chip
                                    key="date"
                                    label={`Date: ${start || '∞'} - ${end || '∞'}`}
                                    onDelete={() => handleRemoveFilter('dateRange')}
                                    size="small"
                                />
                            );
                        }
                    }
                    return null;
                })}
            </Box>
        </Box>
    );
};

================
File: components/GlobalHeader/GlobalHeader.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import Link from 'next/link';
import { 
    AppBar,
    Toolbar,
    Typography,
    InputBase,
    Box,
    IconButton,
    Paper,
    useMediaQuery,
    useTheme,
    TextField
} from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';
import HelpOutlineIcon from '@mui/icons-material/HelpOutline';
import { styled } from '@mui/material/styles';
import { SearchResult } from '@/types';
import { useSearch } from '@/contexts/SearchContext';

const SearchInput = styled(InputBase)(({ theme }) => ({
    marginLeft: theme.spacing(1),
    flex: 1,
}));

const SearchResults = styled(Paper)(({ theme }) => ({
    position: 'absolute',
    top: '100%',
    left: 0,
    right: 0,
    zIndex: 1,
    marginTop: theme.spacing(1),
    maxHeight: '400px',
    overflow: 'auto'
}));

const ResultGroup = styled(Box)(({ theme }) => ({
    padding: theme.spacing(1, 2)
}));

const GroupHeader = styled(Typography)(({ theme }) => ({
    color: theme.palette.text.secondary,
    fontSize: '0.75rem',
    fontWeight: 600,
    textTransform: 'uppercase',
    marginBottom: theme.spacing(1)
}));

const SearchResultItem = styled(Box)(({ theme }) => ({
    display: 'flex',
    alignItems: 'center',
    padding: theme.spacing(1),
    cursor: 'pointer',
    '&:hover': {
        backgroundColor: theme.palette.action.hover
    }
}));

const TaxDisplay = styled(Typography)(({ theme }) => ({
    fontSize: '1.125rem',
    fontWeight: 600,
    letterSpacing: '0.5px',
    textTransform: 'uppercase',
    color: theme.palette.primary.main,
    display: 'flex',
    alignItems: 'center',
    gap: theme.spacing(1),
    '& .amount': {
        fontWeight: 700,
        color: theme.palette.success.main
    }
}));

// Add children to the component props
interface GlobalHeaderProps {
    children?: React.ReactNode;
}

const GlobalHeader: React.FC<GlobalHeaderProps> = ({ children }) => {
    const { searchQuery, setSearchQuery } = useSearch();
    const [showSearchResults, setShowSearchResults] = useState(false);
    const [isSearchExpanded, setIsSearchExpanded] = useState(false);
    const searchRef = useRef<HTMLDivElement>(null);
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    const defaultSearchResults: SearchResult[] = [
        { id: '1', type: 'W-2', name: 'Google Inc', group: 'W-2 Employers' },
        { id: '2', type: '1099', name: 'Freelance Client', group: '1099 Payers' },
        { id: '3', type: 'expense', name: 'Office Supplies', group: 'Vendors' },
        { id: '4', type: 'donation', name: 'Red Cross', group: 'Charities' },
    ];

    const [searchResults, setSearchResults] = useState([...defaultSearchResults]);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (searchRef.current && !searchRef.current.contains(event.target as Node)) {
                setShowSearchResults(false);
                if (isMobile) setIsSearchExpanded(false);
            }
        };

        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, [isMobile]);

    const handleSearchFocus = () => {
        setShowSearchResults(true);
        setIsSearchExpanded(true);
    };

    const handleSearchClick = () => {
        if (isMobile && !isSearchExpanded) {
            setIsSearchExpanded(true);
        }
    };

    const groupedResults = searchResults.reduce((acc, result) => ({
        ...acc,
        [result.group]: [...(acc[result.group] || []), result]
    }), {} as Record<string, SearchResult[]>);

    return (
        <AppBar 
            position="fixed" 
            color="default" 
            elevation={1}
            sx={{ 
                zIndex: theme => theme.zIndex.drawer + 1,
                borderRadius: 0,
                '& .MuiToolbar-root': {
                    borderRadius: 0,
                }
            }}
        >
            <Toolbar>
                {children}
                <Typography
                    variant="h6"
                    component={Link}
                    href="/"
                    sx={{ 
                        textDecoration: 'none',
                        color: 'inherit',
                        flexGrow: 0,
                        display: isMobile && isSearchExpanded ? 'none' : 'block'
                    }}
                >
                    ten40
                </Typography>

                <Box sx={{ 
                    flexGrow: 1, 
                    display: 'flex', 
                    justifyContent: 'center',
                    visibility: (isMobile && isSearchExpanded) ? 'hidden' : 'visible',
                    py: 1
                }}>
                    <TaxDisplay>
                        CURRENT TAX: <span className="amount">+$500</span>
                    </TaxDisplay>
                </Box>

                <Box sx={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    gap: 2,
                    ml: 'auto'
                }}>
                    <Box 
                        ref={searchRef}
                        sx={{ 
                            position: 'relative',
                            width: isSearchExpanded ? '100%' : 'auto',
                            maxWidth: '300px',
                            transition: 'width 0.2s ease-in-out'
                        }}
                    >
                        {(!isMobile || isSearchExpanded) && (
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                <SearchIcon sx={{ color: 'text.secondary', mr: 1 }} />
                                <SearchInput
                                    placeholder="Search..."
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                    onFocus={handleSearchFocus}
                                    onClick={handleSearchClick}
                                    sx={{ width: isSearchExpanded ? '100%' : '200px' }}
                                />
                            </Box>
                        )}
                        {showSearchResults && (
                            <SearchResults elevation={3}>
                                {Object.entries(groupedResults).map(([group, results]) => (
                                    <ResultGroup key={group}>
                                        <GroupHeader>{group}</GroupHeader>
                                        {results.map((result) => (
                                            <SearchResultItem key={result.id}>
                                                <Typography variant="body2" color="text.secondary" sx={{ mr: 1 }}>
                                                    {result.type}
                                                </Typography>
                                                <Typography variant="body2">
                                                    {result.name}
                                                </Typography>
                                            </SearchResultItem>
                                        ))}
                                    </ResultGroup>
                                ))}
                            </SearchResults>
                        )}
                    </Box>

                    {(!isMobile || !isSearchExpanded) && (
                        <IconButton
                            onClick={() => {/* TODO: Implement help panel */}}
                            title="Get Help"
                            size="small"
                            sx={{ ml: 1 }}
                        >
                            <HelpOutlineIcon />
                        </IconButton>
                    )}
                </Box>
            </Toolbar>
        </AppBar>
    );
};

export default GlobalHeader;

================
File: components/Layout/Layout.tsx
================
import React, { useState } from 'react';
import { Box, IconButton, useMediaQuery, useTheme } from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import { LeftNav } from '../LeftNav/LeftNav';
import GlobalHeader from '../GlobalHeader/GlobalHeader';

interface LayoutProps {
    children: React.ReactNode;
}

const DRAWER_WIDTH = 250;
const HEADER_HEIGHT = 64;

export const Layout: React.FC<LayoutProps> = ({ children }) => {
    const [mobileOpen, setMobileOpen] = useState(false);
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    const handleDrawerToggle = () => {
        setMobileOpen(!mobileOpen);
    };

    return (
        <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
            <GlobalHeader>
                {isMobile && (
                    <IconButton
                        color="inherit"
                        aria-label="open drawer"
                        edge="start"
                        onClick={handleDrawerToggle}
                        sx={{ mr: 2, display: { sm: 'none' } }}
                    >
                        <MenuIcon />
                    </IconButton>
                )}
            </GlobalHeader>
            
            <Box sx={{ display: 'flex', flex: 1 }}>
                <LeftNav 
                    mobileOpen={mobileOpen} 
                    onMobileClose={() => setMobileOpen(false)} 
                />
                
                <Box
                    component="main"
                    sx={{
                        flexGrow: 1,
                        minHeight: `calc(100vh - ${HEADER_HEIGHT}px)`,
                        mt: `${HEADER_HEIGHT}px`,
                        width: '100%',
                        position: 'relative',
                        pl: { sm: `${DRAWER_WIDTH}px` },
                    }}
                >
                    {children}
                </Box>
            </Box>
        </Box>
    );
};

================
File: components/LeftNav/LeftNav.tsx
================
import React from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import {
    Drawer,
    List,
    ListItem,
    ListItemButton,
    ListItemIcon,
    ListItemText,
    useTheme,
    useMediaQuery,
    IconButton,
    Box,
} from '@mui/material';
import { styled } from '@mui/material/styles';
import DashboardIcon from '@mui/icons-material/Dashboard';
import DescriptionIcon from '@mui/icons-material/Description';
import ReceiptIcon from '@mui/icons-material/Receipt';
import PersonIcon from '@mui/icons-material/Person';
import CloseIcon from '@mui/icons-material/Close';

const DRAWER_WIDTH = 250;
const HEADER_HEIGHT = 64; // Standard MUI AppBar height

interface NavItem {
    path: string;
    label: string;
    icon: React.ReactNode;
}

const NAV_ITEMS: NavItem[] = [
    { path: '/dashboard', label: 'Dashboard', icon: <DashboardIcon /> },
    { path: '/documents', label: 'Documents', icon: <DescriptionIcon /> },
    { path: '/1040', label: '1040', icon: <ReceiptIcon /> },
    { path: '/profile', label: 'Profile', icon: <PersonIcon /> },
];

const StyledDrawer = styled(Drawer)(({ theme }) => ({
    width: DRAWER_WIDTH,
    flexShrink: 0,
    '& .MuiDrawer-paper': {
        width: DRAWER_WIDTH,
        boxSizing: 'border-box',
        borderRight: `1px solid ${theme.palette.divider}`,
        backgroundColor: theme.palette.background.paper,
        height: `calc(100% - ${HEADER_HEIGHT}px)`,
        top: HEADER_HEIGHT,
    },
}));

interface LeftNavProps {
    mobileOpen: boolean;
    onMobileClose: () => void;
}

export const LeftNav: React.FC<LeftNavProps> = ({ mobileOpen, onMobileClose }) => {
    const router = useRouter();
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    const isSelected = (path: string, currentPath: string) => {
        if (path === '/documents') {
            return currentPath === path || currentPath.startsWith('/receipt/');
        }
        return currentPath === path;
    };

    const drawer = (
        <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
            {isMobile && (
                <Box sx={{ 
                    display: 'flex', 
                    justifyContent: 'flex-end', 
                    p: 1,
                    borderBottom: 1,
                    borderColor: 'divider'
                }}>
                    <IconButton onClick={onMobileClose} size="small">
                        <CloseIcon />
                    </IconButton>
                </Box>
            )}
            <List sx={{ flex: 1, pt: isMobile ? 0 : 2 }}>
                {NAV_ITEMS.map(({ path, label, icon }) => (
                    <ListItem key={path} disablePadding>
                        <ListItemButton
                            component={Link}
                            href={path}
                            selected={isSelected(path, router.pathname)}
                            onClick={isMobile ? onMobileClose : undefined}
                            sx={{
                                py: 1.5,
                                px: 2,
                                '&.Mui-selected': {
                                    bgcolor: 'primary.light',
                                    color: 'primary.main',
                                    '&:hover': {
                                        bgcolor: 'primary.light',
                                    },
                                    '& .MuiListItemIcon-root': {
                                        color: 'primary.main',
                                    },
                                },
                            }}
                        >
                            <ListItemIcon sx={{ minWidth: 40 }}>
                                {icon}
                            </ListItemIcon>
                            <ListItemText 
                                primary={label}
                                primaryTypographyProps={{
                                    fontSize: '0.9375rem',
                                    fontWeight: 600,
                                }}
                            />
                        </ListItemButton>
                    </ListItem>
                ))}
            </List>
        </Box>
    );

    return (
        <>
            {/* Desktop permanent drawer */}
            {!isMobile && (
                <StyledDrawer
                    variant="permanent"
                    open
                >
                    {drawer}
                </StyledDrawer>
            )}

            {/* Mobile temporary drawer */}
            {isMobile && (
                <Drawer
                    variant="temporary"
                    open={mobileOpen}
                    onClose={onMobileClose}
                    ModalProps={{
                        keepMounted: true,
                    }}
                    sx={{
                        display: { xs: 'block', sm: 'none' },
                        '& .MuiDrawer-paper': { 
                            width: DRAWER_WIDTH,
                            boxSizing: 'border-box',
                            top: HEADER_HEIGHT,
                            height: `calc(100% - ${HEADER_HEIGHT}px)`,
                        },
                    }}
                >
                    {drawer}
                </Drawer>
            )}
        </>
    );
};

================
File: components/ErrorBoundary.tsx
================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Alert, Button, Box } from '@mui/material';

interface Props {
    children: ReactNode;
}

interface State {
    hasError: boolean;
    error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
    public state: State = {
        hasError: false,
        error: null
    };

    public static getDerivedStateFromError(error: Error): State {
        return { hasError: true, error };
    }

    public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        console.error('Uncaught error:', error, errorInfo);
    }

    public render() {
        if (this.state.hasError) {
            return (
                <Box sx={{ p: 2 }}>
                    <Alert 
                        severity="error"
                        action={
                            <Button 
                                color="inherit" 
                                size="small"
                                onClick={() => window.location.reload()}
                            >
                                Reload Page
                            </Button>
                        }
                    >
                        Something went wrong. Please try again.
                    </Alert>
                </Box>
            );
        }

        return this.props.children;
    }
}

================
File: components/ImageViewer.tsx
================
import React from 'react';
import { Box, IconButton, Dialog, DialogTitle } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';

interface ImageViewerProps {
    open: boolean;
    imageUrl: string;
    onClose: () => void;
}

export const ImageViewer: React.FC<ImageViewerProps> = ({ open, imageUrl, onClose }) => {
    if (!open) return null;

    return (
        <Dialog 
            open={open} 
            onClose={onClose}
            maxWidth="lg"
            fullWidth
        >
            <DialogTitle sx={{ 
                m: 0, 
                p: 2,
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center'
            }}>
                Receipt Image
                <IconButton
                    aria-label="close"
                    onClick={onClose}
                    sx={{ color: 'text.secondary' }}
                >
                    <CloseIcon />
                </IconButton>
            </DialogTitle>
            <Box sx={{ bgcolor: 'black', p: 2 }}>
                <Box sx={{ 
                    display: 'flex', 
                    justifyContent: 'center', 
                    alignItems: 'center',
                    maxHeight: 'calc(90vh - 100px)',
                    overflow: 'auto'
                }}>
                    <img 
                        src={imageUrl}
                        alt="Receipt"
                        style={{
                            maxWidth: '100%',
                            height: 'auto',
                            objectFit: 'contain'
                        }}
                    />
                </Box>
            </Box>
        </Dialog>
    );
};

================
File: components/JsonViewer.tsx
================
import React from 'react';
import { Paper, Box } from '@mui/material';
import { DialogWrapper } from './common/DialogWrapper';

interface JsonViewerProps {
    data: any;
    onClose: () => void;
}

export const JsonViewer: React.FC<JsonViewerProps> = ({ data, onClose }) => {
    return (
        <DialogWrapper
            title="Receipt Data"
            open={true}
            onClose={onClose}
        >
            <Paper 
                sx={{ 
                    p: 2, 
                    bgcolor: 'grey.100',
                    maxHeight: '60vh',
                    overflow: 'auto'
                }}
            >
                <pre style={{ margin: 0, fontSize: '0.875rem' }}>
                    {JSON.stringify(data, null, 2)}
                </pre>
            </Paper>
        </DialogWrapper>
    );
};

================
File: components/ProtectedRoute.tsx
================
import { useEffect } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from '@/contexts/AuthContext';

export function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { isAuthenticated } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!isAuthenticated && router.pathname !== '/login') {
      router.push('/login');
    }
  }, [isAuthenticated, router]);

  if (!isAuthenticated) {
    return null;
  }

  return <>{children}</>;
}

================
File: components/ReceiptDetail.tsx
================
import { useState, useEffect } from 'react';
import { Box, Typography, Paper, Grid, Skeleton } from '@mui/material';
import { fetchReceipt } from '../lib/api/documents';
import ErrorMessage from './common/ErrorMessage';
import { Receipt } from '../types';

interface ReceiptDetailProps {
  receiptId: string | string[] | undefined;
}

export default function ReceiptDetail({ receiptId }: ReceiptDetailProps) {
  const [receipt, setReceipt] = useState<Receipt | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadReceipt = async () => {
      if (!receiptId) return;
      
      try {
        setLoading(true);
        const data = await fetchReceipt(receiptId.toString());
        setReceipt(data);
      } catch (err) {
        setError('Failed to load receipt details');
        console.error('Error loading receipt:', err);
      } finally {
        setLoading(false);
      }
    };

    loadReceipt();
  }, [receiptId]);

  if (loading) {
    return <ReceiptSkeleton />;
  }

  if (error) {
    return <ErrorMessage message={error} />;
  }

  if (!receipt) {
    return <ErrorMessage message="Receipt not found" />;
  }

  return (
    <Paper elevation={2}>
      <Box p={3}>
        <Grid container spacing={3}>
          <Grid item xs={12} md={6}>
            <Typography variant="h5" gutterBottom>
              Receipt Details
            </Typography>
            <Typography>
              <strong>Date:</strong> {new Date(receipt.date).toLocaleDateString()}
            </Typography>
            <Typography>
              <strong>Total Amount:</strong> ${receipt.totalAmount.toFixed(2)}
            </Typography>
            <Typography>
              <strong>Vendor:</strong> {receipt.vendor}
            </Typography>
            <Typography>
              <strong>Category:</strong> {receipt.category}
            </Typography>
          </Grid>
          <Grid item xs={12} md={6}>
            {receipt.imageUrl && (
              <Box
                component="img"
                src={receipt.imageUrl}
                alt="Receipt"
                sx={{
                  maxWidth: '100%',
                  height: 'auto',
                  borderRadius: 1
                }}
              />
            )}
          </Grid>
        </Grid>
      </Box>
    </Paper>
  );
}

const ReceiptSkeleton = () => (
  <Paper elevation={2}>
    <Box p={3}>
      <Grid container spacing={3}>
        <Grid item xs={12} md={6}>
          <Skeleton variant="text" width="60%" height={40} />
          <Skeleton variant="text" width="40%" />
          <Skeleton variant="text" width="40%" />
          <Skeleton variant="text" width="40%" />
        </Grid>
        <Grid item xs={12} md={6}>
          <Skeleton variant="rectangular" width="100%" height={300} />
        </Grid>
      </Grid>
    </Box>
  </Paper>
);

================
File: components/ReceiptList.tsx
================
import React, { useState, useEffect } from 'react';
import { 
    Container, 
    Typography, 
    Paper, 
    Table, 
    TableBody, 
    TableCell, 
    TableContainer, 
    TableHead, 
    TableRow,
    Button,
    Box,
    IconButton,
    CircularProgress,
    Tooltip,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    DialogContentText,
    Checkbox,
    Alert,
    Snackbar
} from '@mui/material';
import UploadIcon from '@mui/icons-material/Upload';
import VisibilityIcon from '@mui/icons-material/Visibility';
import DataObjectIcon from '@mui/icons-material/DataObject';
import DeleteIcon from '@mui/icons-material/Delete';
import KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import { JsonViewer } from '@/components/JsonViewer';
import { ImageViewer } from '@/components/ImageViewer';
import { UploadArea } from './UploadArea';
import apiClient from '@/services/apiClient';

interface Receipt {
    id: number;
    image_path: string;
    vendor: string;
    amount: string;
    date: string;
    payment_method: string;
    category: string;
    content: any;
}

type SortField = 'vendor' | 'amount' | 'date' | 'payment_method' | 'category';
type SortDirection = 'asc' | 'desc';

export const ReceiptList = () => {
    const [receipts, setReceipts] = useState<Receipt[]>([]);
    const [selectedImage, setSelectedImage] = useState<string | null>(null);
    const [selectedJson, setSelectedJson] = useState<any | null>(null);
    const [isUploading, setIsUploading] = useState(false);
    const [uploadError, setUploadError] = useState<string | null>(null);
    const [deleteConfirmOpen, setDeleteConfirmOpen] = useState<number | null>(null);
    const [isDeleting, setIsDeleting] = useState(false);
    const [sortField, setSortField] = useState<SortField>('date');
    const [sortDirection, setSortDirection] = useState<SortDirection>('desc');
    const [selectedReceipts, setSelectedReceipts] = useState<number[]>([]);
    const [showBulkDeleteConfirm, setShowBulkDeleteConfirm] = useState(false);
    const [bulkActionStatus, setBulkActionStatus] = useState<{
        show: boolean;
        message: string;
        type: 'success' | 'error';
    }>({ show: false, message: '', type: 'success' });

    const fetchReceipts = async () => {
        try {
            const { data } = await apiClient.get<Receipt[]>('/receipts');
            setReceipts(data);
        } catch (error) {
            console.error('Error fetching receipts:', error);
        }
    };

    useEffect(() => {
        fetchReceipts();
    }, []);

    const handleFileUpload = async (file: File) => {
        console.log('Starting file upload for:', file.name);
        
        // Check file type
        if (!file.type.match(/^image\/(jpeg|png)$/)) {
            const error = 'Invalid file type. Please upload a JPEG or PNG image.';
            console.error(error);
            setUploadError(error);
            return;
        }

        if (file.size > 15 * 1024 * 1024) {
            const error = 'File size too large. Maximum size is 15MB.';
            console.error(error);
            setUploadError(error);
            return;
        }

        setIsUploading(true);
        setUploadError(null);
        const formData = new FormData();
        formData.append('file', file);

        try {
            console.log('Sending request to /api/upload');
            
            await apiClient.post('/upload', formData, {
                headers: { 'Content-Type': 'multipart/form-data' }
            });
            await fetchReceipts();
        } catch (error) {
            const message = error instanceof Error ? error.message : 'Upload failed';
            console.error('Upload error:', error);
            setUploadError(message);
        } finally {
            setIsUploading(false);
        }
    };

    const handleDeleteConfirm = async () => {
        if (deleteConfirmOpen === null) return;

        setIsDeleting(true);
        try {
            await apiClient.delete(`/receipts/${deleteConfirmOpen}`);
            await fetchReceipts();
        } catch (error) {
            console.error('Delete error:', error);
        } finally {
            setIsDeleting(false);
            setDeleteConfirmOpen(null);
        }
    };

    const sortReceipts = (receipts: Receipt[]): Receipt[] => {
        return [...receipts].sort((a, b) => {
            const aValue = a[sortField];
            const bValue = b[sortField];
            
            const comparison = sortDirection === 'asc' 
                ? String(aValue).localeCompare(String(bValue))
                : String(bValue).localeCompare(String(aValue));
            
            return comparison;
        });
    };

    const handleSort = (field: SortField) => {
        if (field === sortField) {
            setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
        } else {
            setSortField(field);
            setSortDirection('asc');
        }
    };

    const SortIcon = ({ field }: { field: SortField }) => {
        if (sortField !== field) return (
            <KeyboardArrowUpIcon 
                sx={{ 
                    width: 16, 
                    height: 16, 
                    color: 'text.disabled' 
                }} 
            />
        );
        return sortDirection === 'asc' 
            ? <KeyboardArrowUpIcon sx={{ width: 16, height: 16 }} />
            : <KeyboardArrowDownIcon sx={{ width: 16, height: 16 }} />;
    };

    const handleSelectAll = (event: React.ChangeEvent<HTMLInputElement>) => {
        if (event.target.checked) {
            setSelectedReceipts(receipts.map(receipt => receipt.id));
        } else {
            setSelectedReceipts([]);
        }
    };

    const handleSelectOne = (id: number) => {
        setSelectedReceipts(prev => {
            if (prev.includes(id)) {
                return prev.filter(receiptId => receiptId !== id);
            } else {
                return [...prev, id];
            }
        });
    };

    const handleBulkDelete = async () => {
        setShowBulkDeleteConfirm(false);
        setIsDeleting(true);
        try {
            const results = await Promise.all(
                selectedReceipts.map(async (id) => {
                    try {
                        await apiClient.delete(`/receipts/${id}`);
                        return { id, success: true };
                    } catch (error) {
                        return { id, success: false };
                    }
                })
            );

            const failedDeletes = results.filter(r => !r.success).length;
            
            if (failedDeletes > 0) {
                setBulkActionStatus({
                    show: true,
                    message: `Failed to delete ${failedDeletes} receipts`,
                    type: 'error'
                });
            } else {
                setBulkActionStatus({
                    show: true,
                    message: 'Successfully deleted selected receipts',
                    type: 'success'
                });
            }
            
            // Clear selections and refresh list regardless of success
            setSelectedReceipts([]);
            await fetchReceipts();
            
        } catch (error) {
            console.error('Bulk delete error:', error);
            setBulkActionStatus({
                show: true,
                message: 'Error deleting receipts',
                type: 'error'
            });
            // Still refresh to ensure UI is in sync
            await fetchReceipts();
        } finally {
            setIsDeleting(false);
        }
    };

    return (
        <Container 
            maxWidth={false} 
            disableGutters 
            sx={{ 
                height: '100%',
                maxWidth: '100%',
                boxSizing: 'border-box',
                px: { xs: 2, sm: 3, md: 4 },
                py: { xs: 2, sm: 3 },
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
            }}
        >
            <Typography 
                variant="h4" 
                component="h1" 
                gutterBottom
                sx={{ 
                    fontSize: { xs: '1.25rem', sm: '1.5rem', md: '2rem' },
                    mb: { xs: 2, sm: 4 },
                    textTransform: 'uppercase'
                }}
            >
                Receipt Organizer
            </Typography>

            <Box sx={{ 
                width: '100%',
                display: 'flex',
                flexDirection: 'column',
                gap: { xs: 2, sm: 4 }
            }}>
                <TableContainer component={Paper}>
                    <UploadArea 
                        onUpload={handleFileUpload} 
                        isUploading={isUploading}
                        error={uploadError}
                    />
                </TableContainer>

                {selectedReceipts.length > 0 && (
                    <Box sx={{ 
                        width: '100%',
                        p: 2,
                        bgcolor: 'primary.light', 
                        borderRadius: 1,
                        display: 'flex',
                        alignItems: 'center',
                        gap: 2
                    }}>
                        <Typography sx={{ color: 'white' }}>
                            {selectedReceipts.length} items selected
                        </Typography>
                        <Button
                            variant="contained"
                            color="error"
                            onClick={() => setShowBulkDeleteConfirm(true)}
                            disabled={isDeleting}
                            size="small"
                        >
                            Delete Selected
                        </Button>
                    </Box>
                )}

                <TableContainer component={Paper} variant="outlined">
                    <Table size="small">
                        <TableHead>
                            <TableRow
                                sx={{
                                    bgcolor: 'grey.50',  // Light grey background
                                    '& th': {  // Target all header cells
                                        borderBottom: '2px solid',
                                        borderColor: 'grey.200',
                                        fontWeight: 600,
                                        color: 'grey.700'
                                    }
                                }}
                            >
                                <TableCell padding="checkbox">
                                    <Checkbox
                                        indeterminate={
                                            selectedReceipts.length > 0 && 
                                            selectedReceipts.length < receipts.length
                                        }
                                        checked={
                                            receipts.length > 0 && 
                                            selectedReceipts.length === receipts.length
                                        }
                                        onChange={handleSelectAll}
                                    />
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('vendor')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Vendor
                                        <SortIcon field="vendor" />
                                    </Box>
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('amount')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Amount
                                        <SortIcon field="amount" />
                                    </Box>
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('date')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Date
                                        <SortIcon field="date" />
                                    </Box>
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('payment_method')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Payment Method
                                        <SortIcon field="payment_method" />
                                    </Box>
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('category')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Category
                                        <SortIcon field="category" />
                                    </Box>
                                </TableCell>
                                <TableCell align="left">Actions</TableCell>
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            {sortReceipts(receipts).map((receipt) => (
                                <TableRow 
                                    key={receipt.id} 
                                    hover
                                    onClick={() => setSelectedImage(receipt.image_path)}
                                    sx={{ 
                                        cursor: 'pointer',
                                        '&:hover': {
                                            bgcolor: 'action.hover',
                                        }
                                    }}
                                >
                                    <TableCell 
                                        padding="checkbox"
                                        onClick={(e) => e.stopPropagation()}
                                    >
                                        <Checkbox
                                            checked={selectedReceipts.includes(receipt.id)}
                                            onChange={() => handleSelectOne(receipt.id)}
                                        />
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.vendor}
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.amount}
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.date}
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.payment_method}
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.category}
                                    </TableCell>
                                    <TableCell 
                                        align="left"
                                        sx={{ 
                                            width: { xs: '140px', sm: '220px' },
                                            pr: { xs: 1, sm: 2 }
                                        }}
                                    >
                                        <Box 
                                            sx={{ 
                                                display: 'flex', 
                                                gap: { xs: 1, sm: 1.5 },
                                                justifyContent: 'flex-start'
                                            }}
                                            onClick={(e) => e.stopPropagation()}
                                        >
                                            <Tooltip title="View Receipt">
                                                <IconButton
                                                    size="small"
                                                    onClick={() => setSelectedImage(receipt.image_path)}
                                                    sx={{ 
                                                        color: 'text.secondary',
                                                        '&:hover': { color: '#2196f3' }
                                                    }}
                                                >
                                                    <VisibilityIcon sx={{ fontSize: 20 }} />
                                                </IconButton>
                                            </Tooltip>
                                            <Tooltip title="View Data">
                                                <IconButton
                                                    size="small"
                                                    onClick={() => setSelectedJson(receipt.content)}
                                                    sx={{ 
                                                        color: 'text.secondary',
                                                        '&:hover': { color: '#2196f3' }
                                                    }}
                                                >
                                                    <DataObjectIcon sx={{ fontSize: 20 }} />
                                                </IconButton>
                                            </Tooltip>
                                            <Tooltip title="Delete">
                                                <IconButton
                                                    size="small"
                                                    onClick={() => setDeleteConfirmOpen(receipt.id)}
                                                    sx={{ 
                                                        color: 'text.secondary',
                                                        '&:hover': { color: '#f44336' }
                                                    }}
                                                >
                                                    <DeleteIcon sx={{ fontSize: 20 }} />
                                                </IconButton>
                                            </Tooltip>
                                        </Box>
                                    </TableCell>
                                </TableRow>
                            ))}
                        </TableBody>
                    </Table>
                </TableContainer>
            </Box>

            {selectedImage && (
                <ImageViewer
                    imagePath={selectedImage}
                    onClose={() => setSelectedImage(null)}
                />
            )}
            {selectedJson && (
                <JsonViewer
                    data={selectedJson}
                    onClose={() => setSelectedJson(null)}
                />
            )}

            <Dialog
                open={deleteConfirmOpen !== null}
                onClose={() => setDeleteConfirmOpen(null)}
            >
                <DialogTitle>
                    Confirm Delete
                </DialogTitle>
                <DialogContent>
                    <DialogContentText>
                        Are you sure you want to delete this receipt? This action cannot be undone.
                    </DialogContentText>
                </DialogContent>
                <DialogActions>
                    <Button
                        onClick={() => setDeleteConfirmOpen(null)}
                        color="inherit"
                    >
                        Cancel
                    </Button>
                    <Button
                        onClick={handleDeleteConfirm}
                        color="error"
                        variant="contained"
                        disabled={isDeleting}
                    >
                        {isDeleting ? 'Deleting...' : 'Delete'}
                    </Button>
                </DialogActions>
            </Dialog>

            <Dialog
                open={showBulkDeleteConfirm}
                onClose={() => setShowBulkDeleteConfirm(false)}
            >
                <DialogTitle>
                    Confirm Delete
                </DialogTitle>
                <DialogContent>
                    <DialogContentText>
                        Are you sure you want to delete {selectedReceipts.length} selected receipts? 
                        This action cannot be undone.
                    </DialogContentText>
                </DialogContent>
                <DialogActions>
                    <Button
                        onClick={() => setShowBulkDeleteConfirm(false)}
                        color="inherit"
                    >
                        Cancel
                    </Button>
                    <Button
                        onClick={handleBulkDelete}
                        color="error"
                        variant="contained"
                        disabled={isDeleting}
                    >
                        {isDeleting ? 'Deleting...' : 'Delete'}
                    </Button>
                </DialogActions>
            </Dialog>

            <Snackbar
                open={bulkActionStatus.show}
                autoHideDuration={6000}
                onClose={() => setBulkActionStatus(prev => ({ ...prev, show: false }))}
            >
                <Alert 
                    severity={bulkActionStatus.type}
                    onClose={() => setBulkActionStatus(prev => ({ ...prev, show: false }))}
                >
                    {bulkActionStatus.message}
                </Alert>
            </Snackbar>
        </Container>
    );
};

export default ReceiptList;

================
File: components/ReceiptTable.tsx
================
import React from 'react';
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Paper,
    IconButton,
    Box,
    Tooltip
} from '@mui/material';
import VisibilityIcon from '@mui/icons-material/Visibility';
import DataObjectIcon from '@mui/icons-material/DataObject';
import DeleteIcon from '@mui/icons-material/Delete';
import { Receipt } from '@/types';

interface ReceiptTableProps {
    receipts: Receipt[];
    onViewImage: (imagePath: string) => void;
    onViewJson: (content: any) => void;
    onDelete: (id: number) => void;
}

export const ReceiptTable: React.FC<ReceiptTableProps> = ({
    receipts,
    onViewImage,
    onViewJson,
    onDelete
}) => {
    return (
        <TableContainer component={Paper}>
            <Table size="small">
                <TableHead>
                    <TableRow>
                        <TableCell>Vendor</TableCell>
                        <TableCell>Amount</TableCell>
                        <TableCell>Date</TableCell>
                        <TableCell>Payment Method</TableCell>
                        <TableCell>Category</TableCell>
                        <TableCell align="right">Actions</TableCell>
                    </TableRow>
                </TableHead>
                <TableBody>
                    {receipts.map((receipt) => (
                        <TableRow key={receipt.id}>
                            <TableCell>{receipt.vendor}</TableCell>
                            <TableCell>{receipt.amount}</TableCell>
                            <TableCell>{receipt.date}</TableCell>
                            <TableCell>{receipt.payment_method}</TableCell>
                            <TableCell>{receipt.category}</TableCell>
                            <TableCell align="right">
                                <Box sx={{ display: 'flex', justifyContent: 'flex-end', gap: 1 }}>
                                    {receipt.image_path && (
                                        <Tooltip title="View Receipt">
                                            <IconButton
                                                size="small"
                                                onClick={() => onViewImage(receipt.image_path!)}
                                            >
                                                <VisibilityIcon fontSize="small" />
                                            </IconButton>
                                        </Tooltip>
                                    )}
                                    {receipt.content && (
                                        <Tooltip title="View Data">
                                            <IconButton
                                                size="small"
                                                onClick={() => onViewJson(receipt.content)}
                                            >
                                                <DataObjectIcon fontSize="small" />
                                            </IconButton>
                                        </Tooltip>
                                    )}
                                    <Tooltip title="Delete">
                                        <IconButton
                                            size="small"
                                            onClick={() => onDelete(receipt.id)}
                                        >
                                            <DeleteIcon fontSize="small" />
                                        </IconButton>
                                    </Tooltip>
                                </Box>
                            </TableCell>
                        </TableRow>
                    ))}
                </TableBody>
            </Table>
        </TableContainer>
    );
};

================
File: components/ReceiptUploader.tsx
================
import React, { useCallback, useState, useEffect } from 'react';
import { 
    Box, 
    Typography, 
    LinearProgress, 
    Button,
    styled
} from '@mui/material';
import UploadIcon from '@mui/icons-material/Upload';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import ErrorIcon from '@mui/icons-material/Error';
import { ReceiptTable } from './common';
import { ImageViewer } from './ImageViewer';
import { JsonViewer } from './JsonViewer';
import { Receipt } from '@/types';
import apiClient from '@/services/apiClient';

const HiddenInput = styled('input')({
    display: 'none'
});

export const ReceiptUploader: React.FC = () => {
    const [isDragging, setIsDragging] = useState(false);
    const [uploadProgress, setUploadProgress] = useState(0);
    const [uploadStatus, setUploadStatus] = useState<'idle' | 'uploading' | 'success' | 'error'>('idle');
    const [fileName, setFileName] = useState("");
    const [receipts, setReceipts] = useState<Receipt[]>([]);
    const [selectedImage, setSelectedImage] = useState<string | null>(null);
    const [selectedJson, setSelectedJson] = useState<any | null>(null);
    const [uploadError, setUploadError] = useState<string | null>(null);
    const [deleteConfirmOpen, setDeleteConfirmOpen] = useState<number | null>(null);

    // Fetch receipts on component mount
    useEffect(() => {
        fetchReceipts();
    }, []);

    const fetchReceipts = async () => {
        try {
            const { data } = await apiClient.get<Receipt[]>('/receipts');
            setReceipts(data);
        } catch (error) {
            console.error('Error fetching receipts:', error);
        }
    };

    const handleDragEnter = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    }, []);

    const handleDragLeave = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    }, []);

    const handleDragOver = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
    }, []);

    const validateFile = (file: File) => {
        const validTypes = ['image/jpeg', 'image/png'];
        if (!validTypes.includes(file.type)) {
            setUploadError('Only JPEG and PNG files are supported');
            setUploadStatus('error');
            return false;
        }
        return true;
    };

    const handleDrop = useCallback(async (e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
        
        const files = e.dataTransfer.files;
        if (files.length) {
            const file = files[0];
            if (validateFile(file)) {
                await handleUpload(file);
            }
        }
    }, []);

    const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file && validateFile(file)) {
            await handleUpload(file);
        }
    };

    const handleUpload = async (file: File) => {
        setFileName(file.name);
        setUploadStatus('uploading');
        setUploadProgress(0);
        setUploadError(null);

        const formData = new FormData();
        formData.append('file', file);

        try {
            const { data } = await apiClient.post('/upload', formData, {
                headers: { 'Content-Type': 'multipart/form-data' }
            });

            setUploadStatus('success');
            setUploadProgress(100);
            await fetchReceipts();
        } catch (error) {
            console.error('Upload error:', error);
            setUploadStatus('error');
            setUploadError(error instanceof Error ? error.message : 'Upload failed');
        }
    };

    return (
        <>
            <Box
                sx={{
                    position: 'relative',
                    width: '100%',
                    height: '256px', // equivalent to h-64
                    borderRadius: 2,
                    border: '2px dashed',
                    borderColor: theme => {
                        if (uploadStatus === "success") return 'success.main';
                        if (uploadStatus === "error") return 'error.main';
                        return isDragging ? 'primary.main' : 'divider';
                    },
                    bgcolor: theme => {
                        if (uploadStatus === "success") return 'success.light';
                        if (uploadStatus === "error") return 'error.light';
                        return isDragging ? 'primary.light' : 'grey.50';
                    },
                    transition: 'all 0.2s ease-in-out',
                    cursor: 'pointer'
                }}
                onDragEnter={handleDragEnter}
                onDragOver={handleDragOver}
                onDragLeave={handleDragLeave}
                onDrop={handleDrop}
                role="button"
                tabIndex={0}
                aria-label="Upload receipt"
            >
                <Box
                    sx={{
                        position: 'absolute',
                        inset: 0,
                        display: 'flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        justifyContent: 'center',
                        p: 3,
                        textAlign: 'center'
                    }}
                >
                    <Box sx={{ 
                        mb: 2,
                        color: theme => {
                            if (uploadStatus === "success") return 'success.main';
                            if (uploadStatus === "error") return 'error.main';
                            return isDragging ? 'primary.main' : 'text.secondary';
                        }
                    }}>
                        {uploadStatus === "success" ? <CheckCircleIcon sx={{ fontSize: 48 }} />
                            : uploadStatus === "error" ? <ErrorIcon sx={{ fontSize: 48 }} />
                            : <UploadIcon sx={{ fontSize: 48 }} />
                        }
                    </Box>

                    <Typography 
                        variant="h6" 
                        sx={{ mb: 1, color: 'text.primary' }}
                    >
                        {uploadStatus === "success" ? "Upload Complete!"
                            : uploadStatus === "error" ? "Upload Failed"
                            : "Drag and drop your receipt here"}
                    </Typography>

                    <Typography 
                        variant="body2" 
                        sx={{ mb: 2, color: 'text.secondary' }}
                    >
                        {uploadStatus === "error" ? uploadError
                            : "Or click to browse files (JPEG, PNG)"}
                    </Typography>

                    {uploadStatus === 'idle' && (
                        <label>
                            <HiddenInput
                                type="file"
                                accept="image/jpeg,image/png"
                                onChange={handleFileSelect}
                            />
                            <Button
                                variant="contained"
                                component="span"
                                startIcon={<UploadIcon />}
                            >
                                Browse Files
                            </Button>
                        </label>
                    )}
                </Box>
            </Box>

            {uploadStatus === 'uploading' && (
                <Box sx={{ mt: 2 }}>
                    <Box sx={{ 
                        display: 'flex', 
                        justifyContent: 'space-between', 
                        mb: 1 
                    }}>
                        <Typography variant="body2" color="text.secondary">
                            {fileName}
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                            {uploadProgress}%
                        </Typography>
                    </Box>
                    <LinearProgress 
                        variant="determinate" 
                        value={uploadProgress}
                        sx={{ height: 8, borderRadius: 1 }}
                    />
                </Box>
            )}

            <Box sx={{ mt: 4 }}>
                <ReceiptTable 
                    receipts={receipts}
                    onViewImage={setSelectedImage}
                    onViewJson={setSelectedJson}
                    onDelete={setDeleteConfirmOpen}
                />
            </Box>

            {selectedImage && (
                <ImageViewer
                    imagePath={selectedImage}
                    onClose={() => setSelectedImage(null)}
                />
            )}
            
            {selectedJson && (
                <JsonViewer
                    data={selectedJson}
                    onClose={() => setSelectedJson(null)}
                />
            )}
        </>
    );
};

export default ReceiptUploader;

================
File: components/RouteGuard.tsx
================
import { useEffect } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from '../contexts/AuthContext';

export const RouteGuard: React.FC<{children: React.ReactNode}> = ({ children }) => {
    const router = useRouter();
    const { isAuthenticated } = useAuth();
    
    useEffect(() => {
        // Check if we're on a protected route
        if (!isAuthenticated && router.pathname !== '/login' && router.pathname !== '/signup') {
            router.push('/login');
        }
    }, [isAuthenticated, router]);
    
    return <>{children}</>;
};

================
File: components/UploadArea.tsx
================
import React from 'react';
import { 
    Paper, 
    Box, 
    Typography, 
    Button, 
    LinearProgress, 
    Alert 
} from '@mui/material';
import UploadIcon from '@mui/icons-material/Upload';
import { useDropzone } from 'react-dropzone';

interface UploadAreaProps {
    onUpload: (file: File) => Promise<void>;
    isUploading: boolean;
    error?: string | null;
}

export const UploadArea: React.FC<UploadAreaProps> = ({ onUpload, isUploading, error }) => {
    const { getRootProps, getInputProps, isDragActive } = useDropzone({
        accept: {
            'image/jpeg': ['.jpg', '.jpeg'],
            'image/png': ['.png']
        },
        multiple: false,
        disabled: isUploading,
        onDrop: async (acceptedFiles) => {
            if (acceptedFiles?.[0]) {
                await onUpload(acceptedFiles[0]);
            }
        }
    });

    return (
        <Paper 
            {...getRootProps()}
            variant="outlined" 
            sx={{ 
                p: { xs: 1.5, sm: 2, md: 4 },
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                gap: { xs: 1, sm: 2 },
                borderStyle: 'dashed',
                position: 'relative',
                cursor: 'pointer',
                borderColor: isDragActive ? 'primary.main' : 'divider',
                bgcolor: isDragActive ? 'action.hover' : 'background.paper',
                transition: 'all 0.2s ease',
                '&:hover': {
                    borderColor: 'primary.main',
                    bgcolor: 'action.hover'
                }
            }}
        >
            <input {...getInputProps()} />
            
            {isUploading && (
                <LinearProgress 
                    sx={{ 
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        right: 0,
                        borderTopLeftRadius: 'inherit',
                        borderTopRightRadius: 'inherit'
                    }}
                />
            )}
            
            <Box 
                sx={{ 
                    bgcolor: 'action.hover',
                    borderRadius: '50%',
                    p: { xs: 1.5, sm: 2 },
                    display: 'flex'
                }}
            >
                <UploadIcon />
            </Box>

            <Button
                variant="contained"
                component="span"
                startIcon={<UploadIcon />}
                disabled={isUploading}
                sx={{
                    width: { xs: '100%', sm: 'auto' },
                    minHeight: { xs: 40, sm: 36 },
                    fontSize: { xs: '0.8125rem', sm: '0.875rem' }
                }}
            >
                {isUploading ? 'Uploading...' : 'Upload Receipt'}
            </Button>

            <Typography 
                variant="body2" 
                color="text.secondary"
                align="center"
                sx={{ 
                    fontSize: { xs: '0.75rem', sm: '0.875rem' }
                }}
            >
                {isDragActive 
                    ? 'Drop the receipt here...'
                    : isUploading 
                        ? 'Processing your receipt...' 
                        : 'Supported formats: JPEG, PNG'
                }
            </Typography>

            {error && (
                <Alert 
                    severity="error" 
                    sx={{ 
                        width: '100%',
                        mt: { xs: 1, sm: 2 }
                    }}
                >
                    {error}
                </Alert>
            )}
        </Paper>
    );
};

================
File: config/index.ts
================
const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3456';

export const config = {
    API_BASE_URL: `${API_URL}/api`,
    API_TIMEOUT: 120000,
} as const;

================
File: contexts/AppContext.tsx
================
import React, { createContext, useContext } from 'react';
import { useSearch } from '../hooks/useSearch';
import { useDocumentManagement } from '../hooks/useDocumentManagement';
import { Receipt } from '@/types';

interface AppContextType {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  documents: {
    uploadReceipt: (file: File) => Promise<Receipt>;
    getReceipts: () => Promise<Receipt[]>;
    deleteReceipt: (id: number) => Promise<void>;
    fetchReceipt: (id: string | string[]) => Promise<Receipt>;
  };
}

const AppContext = createContext<AppContextType | undefined>(undefined);

export const AppContextProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const search = useSearch();
  const documents = useDocumentManagement();

  const value = {
    ...search,
    documents
  };

  return (
    <AppContext.Provider value={value}>
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useAppContext must be used within an AppContextProvider');
  }
  return context;
};

================
File: contexts/AuthContext.tsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';

interface AuthContextType {
    token: string | null;
    setToken: (token: string | null) => void;
    isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const AuthProvider: React.FC<{children: React.ReactNode}> = ({ children }) => {
    const [token, setToken] = useState<string | null>(null);
    
    useEffect(() => {
        // Initialize from localStorage
        const storedToken = localStorage.getItem('auth_token');
        if (storedToken) setToken(storedToken);
    }, []);

    const value = {
        token,
        setToken,
        isAuthenticated: !!token
    };
    
    return (
        <AuthContext.Provider value={value}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) throw new Error('useAuth must be used within AuthProvider');
    return context;
};

================
File: contexts/index.ts
================
export * from './SearchContext';

================
File: contexts/SearchContext.tsx
================
import React, { createContext, useContext, useState } from 'react';

interface SearchContextType {
    searchQuery: string;
    setSearchQuery: (query: string) => void;
}

const SearchContext = createContext<SearchContextType | undefined>(undefined);

export const SearchProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [searchQuery, setSearchQuery] = useState('');

    return (
        <SearchContext.Provider value={{ searchQuery, setSearchQuery }}>
            {children}
        </SearchContext.Provider>
    );
};

export const useSearch = () => {
    const context = useContext(SearchContext);
    if (context === undefined) {
        throw new Error('useSearch must be used within a SearchProvider');
    }
    return context;
};

================
File: hooks/useClickAway.ts
================
import { useState, useEffect, useRef } from 'react';

export const useClickAway = (
  ref: React.RefObject<HTMLElement>, 
  onClickAway: (e: MouseEvent | TouchEvent) => void, 
  delay = 100
) => {
  const [listening, setListening] = useState(false);

  useEffect(() => {
    if (listening) {
      const handleClick = (event: MouseEvent | TouchEvent) => {
        // Ignore clicks on MenuItems and the Select's popup
        const target = event.target as HTMLElement;
        if (target.closest('.MuiMenu-paper')) {
          return;
        }

        if (ref.current && !ref.current.contains(event.target as Node)) {
          onClickAway(event);
          setListening(false);
        }
      };

      const timeoutId = setTimeout(() => {
        document.addEventListener('mousedown', handleClick);
        document.addEventListener('touchstart', handleClick);
      }, delay);

      return () => {
        clearTimeout(timeoutId);
        document.removeEventListener('mousedown', handleClick);
        document.removeEventListener('touchstart', handleClick);
      };
    }
  }, [ref, onClickAway, listening, delay]);

  return (shouldListen: boolean) => setListening(shouldListen);
};

================
File: hooks/useDocumentManagement.ts
================
import { useCallback } from 'react';
import { documentsApi } from '../lib/api/documents';
import { Document, DocumentType, ExpenseDocument } from '@/types';

interface DocumentManagement {
  uploadReceipt: (file: File) => Promise<ExpenseDocument>;
  getReceipts: () => Promise<ExpenseDocument[]>;
  deleteReceipt: (id: string) => Promise<void>;
  fetchReceipt: (id: string | string[]) => Promise<ExpenseDocument>;
}

export const useDocumentManagement = (): DocumentManagement => {
  const uploadReceipt = useCallback(async (file: File) => {
    const response = await documentsApi.uploadDocument(file, 'Expenses' as DocumentType);
    return response.data as ExpenseDocument;
  }, []);

  const getReceipts = useCallback(async () => {
    const response = await documentsApi.getDocuments();
    return response.data.filter(
      (doc): doc is ExpenseDocument => doc.type === 'Expenses'
    );
  }, []);

  const deleteReceipt = useCallback(async (id: string) => {
    try {
      await documentsApi.deleteDocument(id);
    } catch (error) {
      console.error('Delete error:', error);
      throw new Error('Failed to delete receipt. Please try again.');
    }
  }, []);

  const fetchReceipt = useCallback(async (id: string | string[]) => {
    const receiptId = Array.isArray(id) ? id[0] : id;
    const response = await documentsApi.getDocuments();
    const receipt = response.data.find(doc => doc.id === receiptId);
    if (!receipt || receipt.type !== 'Expenses') {
      throw new Error('Receipt not found');
    }
    return receipt as ExpenseDocument;
  }, []);

  return {
    uploadReceipt,
    getReceipts,
    deleteReceipt,
    fetchReceipt
  };
};

================
File: hooks/useSearch.ts
================
import { useState, useCallback } from 'react';

export const useSearch = () => {
  const [searchQuery, setSearchQuery] = useState('');

  const handleSearch = useCallback((query: string) => {
    setSearchQuery(query);
  }, []);

  return {
    searchQuery,
    setSearchQuery: handleSearch
  };
};

================
File: lib/api/auth.ts
================
import apiClient from './client';

export interface SignupData {
  email: string;
  password: string;
  fullName: string;
}

export interface LoginData {
  email: string;
  password: string;
}

export interface AuthResponse {
  access_token: string;
  token_type: string;
}

export const authApi = {
  signup: async (email: string, password: string, fullName: string) => {
    const response = await apiClient.post('/auth/signup', {
      email,
      password,
      fullName
    });
    return response.data;
  },
  
  login: async (data: LoginData): Promise<AuthResponse> => {
    const response = await apiClient.post<AuthResponse>('/auth/login', data);
    const token = response.data.access_token;
    localStorage.setItem('auth_token', token);
    return response.data;
  }
};

================
File: lib/api/client.ts
================
import axios from 'axios';

const apiClient = axios.create({
    baseURL: 'http://localhost:3456/api',
    timeout: 120000
});

// Add auth interceptor
apiClient.interceptors.request.use((config) => {
    const token = localStorage.getItem('auth_token');
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

export default apiClient;

================
File: lib/api/documents.ts
================
import apiClient from './client';
import { DocumentType } from '@/types';

export const documentsApi = {
    getDocuments: () => {
        console.log('API: Fetching documents...');
        return apiClient.get('/receipts')
            .then(response => {
                console.log('API: Received response:', response.data);
                return response;
            });
    },
    uploadDocument: (file: File, type: DocumentType) => {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('type', type);
        const token = localStorage.getItem('auth_token');
        
        return apiClient.post('/upload', formData, {
            headers: {
                'Authorization': `Bearer ${token}`,
                // Don't set Content-Type, let the browser set it with the boundary
            }
        });
    },
    deleteDocument: (id: number): Promise<void> => {
        return apiClient.delete(`/receipts/${id}`);
    },
    deleteDocuments: (ids: number[]): Promise<void> => {
        return apiClient.post('/receipts/bulk-delete', { ids });
    },
    updateDocument: (id: number, updates: Record<string, any>): Promise<void> => {
        return apiClient.patch(`/receipts/${id}/update`, updates);
    },
};

================
File: lib/createEmotionCache.ts
================
import createCache from '@emotion/cache';

export default function createEmotionCache() {
  return createCache({ key: 'css', prepend: true });
}

================
File: pages/documents/index.tsx
================
import React, { useState } from 'react';
import { Box, Container } from '@mui/material';
import { DocumentsTabs } from '@/components/Documents/DocumentsTabs';
import { DocumentsView } from '@/components/Documents/DocumentsView';
import { DocumentUploadArea } from '@/components/Documents/DocumentUploadArea';
import { DocumentUploadFab } from '@/components/Documents/DocumentUploadFab';
import { DocumentType } from '@/types';
import { DocumentFilter } from '@/types/filters';

const DocumentsPage: React.FC = () => {
    const [activeTab, setActiveTab] = useState<DocumentType>('W-2');
    const [refreshTrigger, setRefreshTrigger] = useState(0);
    
    // Persistent filters for each document type
    const [filters, setFilters] = useState<Record<DocumentType, DocumentFilter>>({
        'W-2': {},
        '1099': {},
        'Expenses': {},
        'Donations': {}
    });

    const handleTabChange = (tab: DocumentType) => {
        setActiveTab(tab);
    };

    const handleFilterChange = (newFilters: DocumentFilter) => {
        setFilters(prev => ({
            ...prev,
            [activeTab]: newFilters
        }));
    };

    const handleUploadComplete = () => {
        setRefreshTrigger(prev => prev + 1);
    };

    return (
        <Box 
            sx={{ 
                height: '100%',
                width: '100%',
                position: 'absolute',
                top: 0,
                left: 0,
                overflow: 'auto'
            }}
        >
            <Container maxWidth={false} sx={{ py: 3 }}>
                <DocumentsTabs 
                    activeTab={activeTab}
                    onTabChange={handleTabChange}
                />

                <DocumentUploadArea 
                    activeTab={activeTab}
                    onUploadComplete={handleUploadComplete}
                />

                <DocumentsView 
                    activeTab={activeTab}
                    filters={filters[activeTab]}
                    onFilterChange={handleFilterChange}
                    key={refreshTrigger}
                />

                <DocumentUploadFab />
            </Container>
        </Box>
    );
};

export default DocumentsPage;

================
File: pages/receipt/[id].tsx
================
import { useRouter } from 'next/router';
import ReceiptDetail from '../../components/ReceiptDetail';
import { Box } from '@mui/material';
import LoadingSpinner from '../../components/common/LoadingSpinner';

export default function ReceiptPage() {
  const router = useRouter();
  
  // Wait for the router to be ready and have query parameters
  if (!router.isReady) {
    return <LoadingSpinner />;
  }

  const { id } = router.query;

  return (
    <Box sx={{ p: 3 }}>
      <ReceiptDetail receiptId={id} />
    </Box>
  );
}

================
File: pages/_app.tsx
================
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import type { AppProps } from 'next/app';
import { ErrorBoundary } from '../components/ErrorBoundary';
import { Layout } from '../components/Layout/Layout';
import { theme } from '../styles/theme';
import { CacheProvider } from '@emotion/react';
import createEmotionCache from '../lib/createEmotionCache';
import { SearchProvider } from '../contexts/SearchContext';
import { AppContextProvider } from '../contexts/AppContext';
import { AuthProvider } from '../contexts/AuthContext';
import { RouteGuard } from '../components/RouteGuard';

function MyApp({ Component, pageProps }: AppProps) {
    const clientSideEmotionCache = createEmotionCache();

    return (
        <CacheProvider value={clientSideEmotionCache}>
            <ThemeProvider theme={theme}>
                <SearchProvider>
                    <AppContextProvider>
                        <AuthProvider>
                            <RouteGuard>
                                <ErrorBoundary>
                                    <Layout>
                                        <Component {...pageProps} />
                                    </Layout>
                                </ErrorBoundary>
                            </RouteGuard>
                        </AuthProvider>
                    </AppContextProvider>
                </SearchProvider>
            </ThemeProvider>
        </CacheProvider>
    );
}

export default MyApp;

================
File: pages/1040.tsx
================
import React from 'react';
import { Box, Typography, Paper } from '@mui/material';

const Form1040Page: React.FC = () => {
    return (
        <Box sx={{ 
            height: '100%',
            width: '100%',
            position: 'absolute',
            top: 0,
            left: 0,
            overflow: 'auto',
            px: { xs: 2, sm: 3, md: 4 },
            py: { xs: 2, sm: 3 },
        }}>
            <Typography 
                variant="h4" 
                component="h1" 
                gutterBottom
                sx={{ 
                    fontSize: { xs: '1.25rem', sm: '1.5rem', md: '2rem' },
                    mb: { xs: 2, sm: 4 },
                    textTransform: 'uppercase'
                }}
            >
                Form 1040
            </Typography>
            <Paper sx={{ p: 4 }}>
                <Typography>
                    Your Form 1040 preparation area. This feature is coming soon.
                </Typography>
            </Paper>
        </Box>
    );
};

export default Form1040Page;

================
File: pages/dashboard.tsx
================
import React from 'react';
import { Box, Typography, Paper } from '@mui/material';

const DashboardPage: React.FC = () => {
    return (
        <Box sx={{ 
            height: '100%',
            width: '100%',
            position: 'absolute',
            top: 0,
            left: 0,
            overflow: 'auto',
            px: { xs: 2, sm: 3, md: 4 },
            py: { xs: 2, sm: 3 },
        }}>
            <Typography 
                variant="h4" 
                component="h1" 
                gutterBottom
                sx={{ 
                    fontSize: { xs: '1.25rem', sm: '1.5rem', md: '2rem' },
                    mb: { xs: 2, sm: 4 },
                    textTransform: 'uppercase'
                }}
            >
                Dashboard
            </Typography>
            <Paper sx={{ p: 4 }}>
                <Typography>
                    Welcome to your tax dashboard. This feature is coming soon.
                </Typography>
            </Paper>
        </Box>
    );
};

export default DashboardPage;

================
File: pages/documents-temp.tsx
================
import React, { useState } from 'react';
import { Box, Container } from '@mui/material';
import { DocumentsTabs } from '@/components/Documents/DocumentsTabs';
import { DocumentsTable } from '@/components/Documents/DocumentsTable';
import { DocumentUploadArea } from '@/components/Documents/DocumentUploadArea';
import { DocumentUploadFab } from '@/components/Documents/DocumentUploadFab';
import { DocumentType } from '@/types';
import { DocumentFilter } from '@/types/filters';

const DocumentsPage: React.FC = () => {
    const [activeTab, setActiveTab] = useState<DocumentType>('W-2');
    const [refreshTrigger, setRefreshTrigger] = useState(0);
    
    // Persistent filters for each document type
    const [filters, setFilters] = useState<Record<DocumentType, DocumentFilter>>({
        'W-2': {},
        '1099': {},
        'Expenses': {},
        'Donations': {}
    });

    const handleTabChange = (tab: DocumentType) => {
        setActiveTab(tab);
    };

    const handleFilterChange = (newFilters: DocumentFilter) => {
        setFilters(prev => ({
            ...prev,
            [activeTab]: newFilters
        }));
    };

    const handleUploadComplete = () => {
        setRefreshTrigger(prev => prev + 1);
    };

    return (
        <Box 
            sx={{ 
                height: '100%',
                width: '100%',
                position: 'absolute',
                top: 0,
                left: 0,
                overflow: 'auto'
            }}
        >
            <Container maxWidth={false} sx={{ py: 3 }}>
                <DocumentsTabs 
                    activeTab={activeTab}
                    onTabChange={handleTabChange}
                />

                <DocumentUploadArea 
                    activeTab={activeTab}
                    onUploadComplete={handleUploadComplete}
                />

                <DocumentsTable 
                    type={activeTab}
                    filters={filters[activeTab]}
                    onFilterChange={handleFilterChange}
                    key={refreshTrigger}
                />

                <DocumentUploadFab />
            </Container>
        </Box>
    );
};

export default DocumentsPage;

================
File: pages/index.tsx
================
import { useEffect } from 'react';
import { useRouter } from 'next/router';

export default function HomePage() {
    const router = useRouter();

    useEffect(() => {
        router.replace('/dashboard');
    }, [router]);

    return null;
}

================
File: pages/login.tsx
================
import { useState } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from '../contexts/AuthContext';
import { authApi } from '../lib/api/auth';
import Link from 'next/link';
import { AxiosError } from 'axios';

export default function Login() {
    const router = useRouter();
    const { setToken } = useAuth();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');
        
        console.log('Starting login process for:', email);
        
        try {
            console.log('Calling login API...');
            const response = await authApi.login({ email, password });
            console.log('Login response:', response);
            
            setToken(response.access_token);
            router.push('/documents');
        } catch (err) {
            console.error('Login error:', err);
            if (err instanceof AxiosError) {
                setError(
                    err.response?.data?.detail ||
                    err.response?.data?.message ||
                    'Invalid email or password'
                );
            } else {
                setError('An unexpected error occurred');
            }
        }
    };

    return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50">
            <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow">
                <div>
                    <h2 className="text-center text-3xl font-extrabold text-gray-900">
                        Sign in to your account
                    </h2>
                </div>
                <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
                    {error && (
                        <div className="text-red-500 text-center">
                            {error}
                        </div>
                    )}
                    <div className="rounded-md shadow-sm -space-y-px">
                        <div>
                            <label htmlFor="email" className="sr-only">Email address</label>
                            <input
                                id="email"
                                name="email"
                                type="email"
                                required
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                                placeholder="Email address"
                            />
                        </div>
                        <div>
                            <label htmlFor="password" className="sr-only">Password</label>
                            <input
                                id="password"
                                name="password"
                                type="password"
                                required
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                                placeholder="Password"
                            />
                        </div>
                    </div>

                    <div>
                        <button
                            type="submit"
                            className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                        >
                            Sign in
                        </button>
                    </div>
                </form>
                <div className="text-center">
                    <Link href="/signup" className="text-indigo-600 hover:text-indigo-500">
                        Don't have an account? Sign up
                    </Link>
                </div>
            </div>
        </div>
    );
}

================
File: pages/profile.tsx
================
import React from 'react';
import { Box, Typography, Paper } from '@mui/material';

const ProfilePage: React.FC = () => {
    return (
        <Box sx={{ 
            height: '100%',
            width: '100%',
            position: 'absolute',
            top: 0,
            left: 0,
            overflow: 'auto',
            px: { xs: 2, sm: 3, md: 4 },
            py: { xs: 2, sm: 3 },
        }}>
            <Typography 
                variant="h4" 
                component="h1" 
                gutterBottom
                sx={{ 
                    fontSize: { xs: '1.25rem', sm: '1.5rem', md: '2rem' },
                    mb: { xs: 2, sm: 4 },
                    textTransform: 'uppercase'
                }}
            >
                Profile
            </Typography>
            <Paper sx={{ p: 4 }}>
                <Typography>
                    Your profile settings and preferences. This feature is coming soon.
                </Typography>
            </Paper>
        </Box>
    );
};

export default ProfilePage;

================
File: pages/signup.tsx
================
import { useState } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from '../contexts/AuthContext';
import { authApi } from '../lib/api/auth';
import Link from 'next/link';

export default function Signup() {
    const router = useRouter();
    const { setToken } = useAuth();
    const [formData, setFormData] = useState({
        email: '',
        password: '',
        fullName: ''
    });
    const [error, setError] = useState('');

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');
        
        try {
            const signupData = {
                email: formData.email.trim(),
                password: formData.password,
                fullName: formData.fullName.trim()
            };
            
            console.log('Starting signup process with data:', {
                email: signupData.email,
                fullName: signupData.fullName,
                password: signupData.password
            });
            
            const signupResponse = await authApi.signup(
                signupData.email,
                signupData.password,
                signupData.fullName
            );
            
            console.log('Attempting login...');
            const loginResponse = await authApi.login({
                email: signupData.email,
                password: signupData.password
            });
            
            console.log('Login successful:', loginResponse);            
            setToken(loginResponse.access_token);
            router.push('/documents');
        } catch (err: any) {
            console.error('Signup/Login error:', err);
            setError(
                err.response?.data?.message || 
                err.response?.data?.detail || 
                'Error creating account'
            );
        }
    };

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setFormData({
            ...formData,
            [e.target.name]: e.target.value
        });
    };

    return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50">
            <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow">
                <div>
                    <h2 className="text-center text-3xl font-extrabold text-gray-900">
                        Create your account
                    </h2>
                </div>
                <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
                    {error && (
                        <div className="text-red-500 text-center">
                            {error}
                        </div>
                    )}
                    <div className="rounded-md shadow-sm -space-y-px">
                        <div>
                            <label htmlFor="fullName" className="sr-only">Full Name</label>
                            <input
                                id="fullName"
                                name="fullName"
                                type="text"
                                required
                                value={formData.fullName}
                                onChange={handleChange}
                                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                                placeholder="Full Name"
                            />
                        </div>
                        <div>
                            <label htmlFor="email" className="sr-only">Email address</label>
                            <input
                                id="email"
                                name="email"
                                type="email"
                                required
                                value={formData.email}
                                onChange={handleChange}
                                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                                placeholder="Email address"
                            />
                        </div>
                        <div>
                            <label htmlFor="password" className="sr-only">Password</label>
                            <input
                                id="password"
                                name="password"
                                type="password"
                                required
                                value={formData.password}
                                onChange={handleChange}
                                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                                placeholder="Password"
                            />
                        </div>
                    </div>

                    <div>
                        <button
                            type="submit"
                            className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                        >
                            Create Account
                        </button>
                    </div>
                </form>
                <div className="text-center">
                    <Link href="/login" className="text-indigo-600 hover:text-indigo-500">
                        Already have an account? Sign in
                    </Link>
                </div>
            </div>
        </div>
    );
}

================
File: pages/test-auth.tsx
================


================
File: services/apiClient.ts
================
import axios, { AxiosError, AxiosResponse } from 'axios';

// Custom error class for API errors
export class ApiError extends Error {
    constructor(
        message: string,
        public statusCode: number,
        public data?: any
    ) {
        super(message);
        this.name = 'ApiError';
    }
}

export const apiClient = axios.create({
    baseURL: '/api',
    timeout: Number(process.env.NEXT_PUBLIC_API_TIMEOUT) || 30000,
    headers: {
        'Content-Type': 'application/json',
    },
});

// Request interceptor
apiClient.interceptors.request.use(
    (config) => {
        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);

// Response interceptor
apiClient.interceptors.response.use(
    (response: AxiosResponse) => {
        return response;
    },
    (error: AxiosError) => {
        if (error.response) {
            throw new ApiError(
                error.response.data?.message || 'An error occurred',
                error.response.status,
                error.response.data
            );
        } else if (error.request) {
            throw new ApiError('No response from server', 503);
        } else {
            throw new ApiError(error.message || 'Request configuration error', 500);
        }
    }
);

export default apiClient;

================
File: styles/globals.css
================
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
}

================
File: styles/theme.ts
================
import { createTheme } from '@mui/material/styles';

export const theme = createTheme({
  typography: {
    fontFamily: 'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  components: {
    MuiCssBaseline: {
      styleOverrides: {
        '@keyframes fadeIn': {
          from: { opacity: 0 },
          to: { opacity: 1 },
        },
        '@keyframes slideIn': {
          from: {
            transform: 'translateY(20px)',
            opacity: 0,
          },
          to: {
            transform: 'translateY(0)',
            opacity: 1,
          },
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          transition: 'all 0.2s ease-in-out',
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          borderRadius: 8,
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        root: {
          padding: '12px 16px',
        },
        head: {
          fontWeight: 600,
          backgroundColor: 'rgba(0, 0, 0, 0.02)',
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundColor: '#ffffff',
          color: 'inherit',
          borderRadius: 0,
        }
      }
    },
    MuiToolbar: {
      styleOverrides: {
        root: {
          borderRadius: 0,
          '@media (min-width: 600px)': {
            minHeight: '64px',
            padding: '0 24px',
          },
          '@media (max-width: 599px)': {
            minHeight: '48px',
            padding: '0 16px',
          }
        }
      }
    }
  },
  palette: {
    background: {
      default: '#f8f9fa',
    },
    text: {
      primary: 'rgba(0, 0, 0, 0.87)',
      secondary: 'rgba(0, 0, 0, 0.6)',
    },
  },
});

================
File: types/documents.ts
================
export type DocumentType = 'W-2' | '1099' | 'Expenses' | 'Donations';
export type DocumentStatus = 'Pending' | 'Approved' | 'Rejected';

interface BaseDocument {
    id: string;
    type: DocumentType;
    status: DocumentStatus;
    uploadDate: string;
    image_path: string;
}

export interface W2Document extends BaseDocument {
    type: 'W-2';
    employer: string;
    wages: number;
    fedWithholding: number;
}

export interface Form1099Document extends BaseDocument {
    type: '1099';
    payer: string;
    amount: number;
}

export interface ExpenseDocument extends BaseDocument {
    type: 'Expenses';
    vendor: string;
    amount: number;
    date: string;
    payment_method: string;
    category: string;
}

export interface DonationDocument extends BaseDocument {
    type: 'Donations';
    charityName: string;
    amount: number;
    donationType: string;
}

export type Document = W2Document | Form1099Document | ExpenseDocument | DonationDocument;

================
File: types/filters.ts
================
import { DocumentType } from './index';

export interface BaseFilter {
  type: DocumentType;
  status?: string[];
  dateRange?: {
    start: string;
    end: string;
  };
}

export interface W2Filter extends BaseFilter {
  type: 'W-2';
  employer?: string[];
  wageRange?: {
    min: number;
    max: number;
  };
}

export interface Form1099Filter extends BaseFilter {
  type: '1099';
  employer?: string[];
  amountRange?: {
    min: number;
    max: number;
  };
}

export interface ExpenseFilter extends BaseFilter {
  type: 'Expenses';
  vendor?: string[];
  amountRange?: {
    min: number;
    max: number;
  };
  paymentMethod?: string[];
  category?: string[];
}

export interface DonationFilter extends BaseFilter {
  type: 'Donations';
  charityName?: string[];
  amountRange?: {
    min: number;
    max: number;
  };
  donationType?: string[];
}

export type DocumentFilter = W2Filter | Form1099Filter | ExpenseFilter | DonationFilter;

export interface DocumentFilters {
  vendor?: string;
  expenseType?: string;
  paymentMethod?: string;
  status?: string;
  dateRange?: {
    start: string;
    end: string;
  };
}

================
File: types/index.ts
================
// Document Types
export enum DocumentType {
    EXPENSE = 'Expenses',    // Current primary type for receipts
    W2 = 'W-2',             // Future types
    FORM_1099 = '1099',
    DONATION = 'Donations'
}

export type DocumentStatus = 'pending' | 'processed' | 'error';

// Receipt Types
export interface ReceiptItem {
    name: string;
    price: number;
    quantity: number;
}

export interface Receipt {
    id: number;
    date: string;
    totalAmount: number;
    vendor: string;
    category: string;
    imageUrl?: string;
    image_path?: string;
    items?: Array<{
        description: string;
        amount: number;
    }>;
    content?: any;
    payment_method?: string;
    amount?: string | number;
    replace?: never;
}

// Document Interfaces
export interface BaseDocument {
    id: number;
    type: DocumentType;
    status: DocumentStatus;
    uploadDate: string;
}

export interface W2Document extends BaseDocument {
    type: DocumentType.W2;
    employer: string;
    wages: number;
    fedWithholding: number;
}

export interface Form1099Document extends BaseDocument {
    type: DocumentType.FORM_1099;
    employer: string;
    nonEmpCompensation: number;
}

export interface ExpenseDocument extends BaseDocument {
    type: DocumentType.EXPENSE;
    vendor: string;
    amount: number;
    date: string;
    payment_method: string;
    category: string;
    expenseType: string;
}

export interface DonationDocument extends BaseDocument {
    type: DocumentType.DONATION;
    charityName: string;
    amount: number;
    donationType: string;
    date: string;
}

export type Document = W2Document | Form1099Document | ExpenseDocument | DonationDocument;

// Search Types
export interface SearchResult {
    id: string;
    type: string;
    name: string;
    group: string;
}

================
File: .env.development
================
NEXT_PUBLIC_API_URL=http://localhost:3456
NEXT_PUBLIC_API_TIMEOUT=120000
NODE_OPTIONS=--max-http-header-size=81920

================
File: .eslintrc.js
================
module.exports = {
  extends: [
    'next/core-web-vitals',
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended'
  ],
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint'],
  rules: {
    '@typescript-eslint/no-unused-vars': ['error'],
    '@typescript-eslint/no-explicit-any': ['warn'],
    'react/prop-types': 'off'
  }
};

================
File: .gitignore
================
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: config.ts
================
export const CONFIG = {
    TIMEOUTS: {
        UPLOAD: 120000,  // 2 minutes in milliseconds
        SERVER: 120000,
        PROXY: 120000
    },
    AUTH: {
        TOKEN_KEY: 'auth_token'
    }
} as const;

================
File: next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
    reactStrictMode: true,
    // Disable ESLint during build
    eslint: {
        ignoreDuringBuilds: true,
    },
    async rewrites() {
        // Keep local development working with localhost:3456
        return process.env.NODE_ENV === 'production' ? [] : [
            {
                source: '/api/:path*',
                destination: 'http://localhost:3456/api/:path*',
            }
        ];
    },
    // Keep both local and production image domains
    images: {
        domains: [
            'backend-production-711f.up.railway.app',
            'localhost'
        ],
    }
};

module.exports = nextConfig;

================
File: package.json
================
{
  "name": "receipt-scanner-frontend",
  "version": "1.0.0",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@emotion/cache": "^11.14.0",
    "@emotion/react": "^11.11.3",
    "@emotion/server": "^11.11.0",
    "@emotion/styled": "^11.11.0",
    "@mui/icons-material": "^5.16.11",
    "@mui/material": "^5.x.x",
    "@mui/x-date-pickers": "^6.18.6",
    "date-fns": "^2.30.0",
    "next": "^14.x.x",
    "react": "^18.x.x",
    "react-dom": "^18.x.x",
    "react-dropzone": "^14.2.3"
  },
  "devDependencies": {
    "@types/node": "^20.10.6",
    "@types/react": "^18.2.46",
    "@types/react-dom": "^18.2.18",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "eslint": "^8.0.0",
    "eslint-config-next": "^14.0.4",
    "typescript": "^5.3.3"
  }
}

================
File: railway.toml
================
[build]
builder = "nixpacks"
buildCommand = "npm install && npm run build"

[deploy]
startCommand = "npm run build && npm start"
healthcheckPath = "/"
restartPolicyType = "on_failure"
PORT = "3000"

[deploy.env]
NODE_ENV = "production"
NEXT_PUBLIC_API_URL = "https://backend-production-711f.up.railway.app"

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}
